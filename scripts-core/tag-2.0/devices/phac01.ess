// scripting device support for pha-01 photo-appliance
##require("EsDeviceBase.ess");
##require("../math/EsSpline.ess");
##require("phac01_CorMatrix.ess");

const c_phac01_unitE = "lx";
const c_phac01_unitL = "cd/m<sup>2</sup>";
const c_phac01_unitP = "%";
const c_phac01_unitCT = "K";

// pha01-specific rpcs 
enum PHAC01_Rpid
{
  // Legacy-mode handlers. PHA-01 ids preserved
  //
	LegacyAutosaveIntervalSet = 2048, "VOID_Call_esU8|";
	LegacyAutosaveIntervalGet = 2049, "esU8_Call|";
	LegacyOperationModeSet    = 2056, "VOID_Call_esU8|";
	LegacyOperationModeGet    = 2057, "esU8_Call|";
	LegacyLiveDataGet         = 2058, "esBA_Call|";
	LegacyDataAtIdxGet        = 2060, "esBA_Call_esU16|";
	LegacyDataClear           = 2061, "esBL_Call|";
	LegacyLiveWithBgndStart   = 2073, "VOID_Call_esU16|";
	LegacyBgndPeriodLeftGet   = 2074, "esU16_Call|";

  // Native handlers
  // 
  // Following handlers are used both, in legacy and native modes
  DataCountGet              = 2059, "esU16_Call|Return count of data saved in autonomous mode";
	AllowChargingSet          = 2067, "VOID_Call_esBL|";

  // Pure native handlers
  //
  WorkmodeSet               = 2080, "VOID_Call_esU32|";
  WorkmodeGet               = 2081, "esU32_Call|";
  LiveDataGet               = 2082, "esBA_Call|";
  RawDataGet                = 2083, "esBA_Call|";
  CalibrationClearGet       = 2084, "esBA_Call|";
  CalibrationClearSet       = 2085, "VOID_Call_esBA|";
  CalibrationColorGet       = 2086, "esBA_Call|";
  CalibrationColorSet       = 2087, "VOID_Call_esBA|";
  BgndTmoGet                = 2088, "esU16_Call|";
  BgndTmoSet                = 2089, "VOID_Call_esU16|";
  AutosaveTmoGet            = 2090, "esU16_Call|";
  AutosaveTmoSet            = 2091, "VOID_Call_esU16|";
  DataReset                 = 2092, "VOID_Call|";
  DataAtIdxGet              = 2093, "esBA_Call_esU16|";  
}

// settings defaults
enum PHAC01_Defs
{
  // Autosave intervals in sec
  AutoIntervalMin = 5;
  AutoIntervalMax = 600;
  AutoIntervalDef = 5;
  // Background photo measurement length, in sec
  BgndExposureMin = 5;
  BgndExposureMax = 60;
  BgndExposureDef = 15;
}

// photo appliance operation modes
enum PHAC01_LegacyOpMode 
{
  None          = 0, "NONE";
  Idle          = 1, "IDLE operation";
  Live          = 2, "LIVE operation";
  Autonomous    = 3, "KEO operation";
  LiveWoBgnd    = 4, "LIVE operation with background subtraction";
  Oscilloscope  = 5, "OSCILLOSCOPE operation";
}

/// PHA Color device error flags and bit masks
enum PHAC01_Error
{
  PwrCritical  = 0x00000001, "Battery Low";                         ///< Battery power level is below critical margin
  RTC          = 0x00000002, "RTC error";                           ///< RTC initialization error
  RTC_Invalid  = 0x00000004, "RTC date time corrupt";               ///< RTC date time value is invalid
  Storage      = 0x00000008, "Storage initialization error";        ///< Storage stream could not be opened
  ClearNoCal   = 0x00000010, "Clear sensor calibration is missing"; ///< Clear sensor calibration is missing or invalid
  ColorNoCal   = 0x00000020, "Color sensor calibration is missing"; ///< Color sensor calibration is missing or invalid
  MAX4400x     = 0x00000040, "Color sensor does not respond";       ///< Color sensor MAX4400x does not respond
  I2C          = 0x00000080, "I2C bus error";                       ///< Error condition latched on I2C bus     
}

/// PHA Color operation modes
enum PHAC01_OpMode
{
  None        = 0, "NONE";
  Idle        = 1, "IDLE operation";
  Illuminance = 2, "ILLUMINANCE operation";
  Luminance   = 3, "LUMINANCE operation";
  Oscilloscope= 4, "OSCILLOSCOPE operation";
}

/// PHA Color operation modifiers
enum PHAC01_OpModeModifier
{
  None         = 0, "Normal";                       //< Null modifier, normal operation, just for readability        
  BgndTrim     = 0x10, "Background trimming";       //< Bgnd trimming mode is on (0x1 << 4)
  Autonomous   = 0x20, "Autonomous";                //< Autonomous operation - write measured data into internal storage memory (0x2 << 4)
}

/// PHA Color data state flags
enum PHAC01_DataState
{
  None         = 0, "Normal";                       //< Normal data state, just for readability
  LowSignal    = 0x100, "Low signal";               //< Low value state - no kp data is valid, because slow color sensor output is used (0x1 << 8)
}

/// PHA Color data (in)validity flags
enum PHAC01_DataInvalid
{
  val          = 0x00010000;  //(0x0001 << 16);
  valOrg       = 0x00020000;  //(0x0002 << 16);
  kp           = 0x00040000;  //(0x0004 << 16);
  kpOrg        = 0x00080000;  //(0x0008 << 16);
  kpi          = 0x00100000;  //(0x0010 << 16);
  kpiOrg       = 0x00200000;  //(0x0020 << 16);
  bgnd         = 0x00400000;  //(0x0040 << 16);
  bgndTmo      = 0x00800000;  //(0x0080 << 16);
  xy           = 0x01000000;  //(0x0100 << 16);
  ct           = 0x02000000;  //(0x0200 << 16);
}

/// Data formatting helpers
///
function PHAC01_ValueFmt(val)
var fmt;
{
	if( val < 0 )
		val = 0;
		
	if( val < 10 )
		fmt = "%0.2f";
	else if( val < 100 )
		fmt = "%0.1f";
	else
		fmt = "%0.0f";
	
	return EsStr::format(fmt, val);
}

function PHAC01_CieValueFmt(val, valid)
var fmt;
{
  if( !valid )
    return "--";
  
	if( val < 0 )
		val = 0;
		
	return EsStr::format("%0.6f", val);
}

function PHAC01_PulsationFmt(val)
var fmt;
{
	if( val < 0 )
		val = 0;
		
	if( val < 10 )
		fmt = "%0.1f";
	else
		fmt = "%0.0f";
	
	return EsStr::format(fmt, val);
}

/// Multi part value string creation
function PHAC01_strMultiGet(val, unit, valid)
var mul = 1., result = []; 
{
  if( !valid )
  {
    result += "--";
    result += "--";
  }
  else
  {
		result += PHAC01_ValueFmt( val );
		if( val > 1000. )
		{
			mul = 1000.;
			val /= mul;
		}
		result += PHAC01_ValueFmt( val );
		result += EsStr::format("x%d", mul);
  }
  	
  result += unit;
  return result;
}

/// Multi part pulsation string 
function PHAC01_strMultiNoMulPartGet(val, unit, valid)
var result = [];
{
  if( !valid )
		result += "--";    
  else
		result += PHAC01_PulsationFmt( val );
	
	result += unit;
	return result;
}

/// Create simple string from multistring
function PHAC01_fromStrMulti(multi)
{
	return multi[0] + " " + multi[3];
}

/// The same as above, but for pulsation multistring
function PHAC01_fromStrMultiNoMulPart(multi)
{
	return multi[0] + " " + multi[1];
}

/// Backwards - compatible (legacy) data structures
///

/// Simple PHAC01 data object
object PHAC01_LegacyData 
{
  /// Fields
  esDT   f_ts;
  esF    f_lux;
  esF    f_cdm;
  esU16  f_kp;
  esI8   f_temp;
  
  /// Properties
	///
	/// Timestamp
	property ts;
	read: { return f_ts$value; }
	/// Timestamp string
	property tsStr;
	read: { return f_ts.asString(); }	
	
  /// illuminosity
  property lux;
  read: { return f_lux$value; }
	/// illuminosity string components property
	property luxStrMulti;
	read: { return PHAC01_strMultiGet( $lux, c_phac01_unitE, true); }
	/// illuminosity value string
	property luxStr;
	read: { return PHAC01_fromStrMulti( $luxStrMulti ); }
	
  /// Luminosity
  property cdm;
  read: { return f_cdm$value; }
	/// Luminosity string components
	property cdmStrMulti;
	read: { return PHAC01_strMultiGet( $cdm, c_phac01_unitL, true); }
	/// Luminosity value string
  property cdmStr;
  read: { return PHAC01_fromStrMulti( $cdmStrMulti ); }
	
  /// pulsation coefficient, in %
  property kp;
  read: { return f_kp / 10.; }
	/// pulsation string components
	property kpStrMulti;
	read: {	return PHAC01_strMultiNoMulPartGet( $kp, c_phac01_unitP, true); }
	/// pulsation string
	property kpStr;
  read: { return PHAC01_fromStrMultiNoMulPart( $kpStrMulti ); }
}

// background subtraction data packet
object PHAC01_LegacyDataWoBgnd
{
  esDT    f_ts;
  esF     f_luxOrg;         /// > original illuminosity
  esF     f_luxBgnd;        /// > measured background illuminosity
  esF     f_lux;            /// > illuminosity-bgnd level
  esU16   f_kpOrg;          /// > original pulsation
  esU16   f_kp;             /// > resulting pulsation
  esU16   f_bgndDuration;   /// > duration of background measurements in seconds
  esU16   f_bgndETA;        /// > bgnd measurement countdown in seconds, 0 - bgnd measurement results are valid
 
  /// Properties
	///
	/// Timestamp
	property ts;
	read: { return f_ts$value; }
	/// Timestamp string
	property tsStr;
	read: { return f_ts.asString(); }	
 
 	/// Data validity check
	property valid;
	read: { return 0 == f_bgndETA; }
 
  /// original illuminosity
  property luxOrg;
  read: { return f_luxOrg$value; }
	/// original illuminosity string components
	property luxOrgStrMulti;
	read: { return PHAC01_strMultiGet( $luxOrg, c_phac01_unitE, $valid); }
	/// original illuminosity string
	property luxOrgStr;
	read: { return PHAC01_fromStrMulti( $luxOrgStrMulti ); }	

  /// background illuminosity
  property luxBgnd;
  read: { return f_luxBgnd$value; }
  /// background illuminosity	string components
	property luxBgndStrMulti;
	read: { return PHAC01_strMultiGet( $luxBgnd, c_phac01_unitE, $valid); }
  /// background illuminosity	string
	property luxBgndStr;
	read: { return PHAC01_fromStrMulti( $luxBgndStrMulti ); }	

  /// illuminosity W|O background
  property lux;
  read: { return f_lux$value; }
  /// illuminosity W|O background, string components
	property luxStrMulti;
	read: { return PHAC01_strMultiGet( $lux, c_phac01_unitE, $valid); }
  /// illuminosity W|O background, string
	property luxStr;
	read: { return PHAC01_fromStrMulti( $luxStrMulti ); }

  /// original pulsation coefficient, %
  property kpOrg;
  read: { return f_kpOrg / 10.; }
	property kpOrgStrMulti;
	read: { return PHAC01_strMultiNoMulPartGet( $kpOrg, c_phac01_unitP, $valid ); }
	property kpOrgStr;
  read: { return PHAC01_fromStrMultiNoMulPart( $kpOrgStrMulti ); }

  /// resulting pulsation coefficient, %
  property kp;
  read: { return f_kp / 10.; }
	/// pulsation multi string
	property kpStrMulti;
	read: { return PHAC01_strMultiNoMulPartGet( $kp, c_phac01_unitP, $valid ); }
	/// pulsation string
	property kpStr;
  read: { return PHAC01_fromStrMultiNoMulPart( $kpStrMulti ); }
	
	/// Background exposure duration in seconds
	property bgndExp;
	read: { return f_bgndDuration$value; }
	
	/// Bgnd ETA read access
	property eta;
	read: { return f_bgndETA$value; }
}

/// PHAC01 Health state object
object PHAC01_Health
{
  esU32 f_errors;
  /// Constructor
  new(health)
  {
    f_errors = health;
  }
  /// Return health errors as string collection
  function errorsAsStrings()
  var result = []; 
  {
    if(f_errors & PHAC01_Error$$PwrCritical)
      result += PHAC01_Error$$PwrCritical$$label;
    if(f_errors & PHAC01_Error$$I2C)
      result += PHAC01_Error$$I2C$$label;
    if(f_errors & PHAC01_Error$$RTC)
      result += PHAC01_Error$$RTC$$label;
    if(f_errors & PHAC01_Error$$RTC_Invalid)
      result += PHAC01_Error$$RTC_Invalid$$label;
    if(f_errors & PHAC01_Error$$Storage)
      result += PHAC01_Error$$Storage$$label;
    if(f_errors & PHAC01_Error$$ClearNoCal)
      result += PHAC01_Error$$ClearNoCal$$label;
    if(f_errors & PHAC01_Error$$ColorNoCal)
      result += PHAC01_Error$$ColorNoCal$$label;
    if(f_errors & PHAC01_Error$$MAX4400x)
      result += PHAC01_Error$$MAX4400x$$label;
  
    return result;
  }
  /// Return health errors as string
  function asString()
  {
    return EsStr::fromArray(errorsAsStrings(), "; ", "", "");
  }
	
	/// Properties
	///
	property errors;
	read: { return f_errors$value; }
  /// return true if health critical error was latched
  property hasCriticalError;
  read: { return f_errors & 
                                ( PHAC01_Error$$I2C|
                                  PHAC01_Error$$RTC|
                                  PHAC01_Error$$Storage|
                                  PHAC01_Error$$MAX4400x ); 
        }
  /// return true if health non-critical error was latched
  property hasNonCriticalError;
  read: { return f_errors & 
                                ( PHAC01_Error$$RTC_Invalid|
                                  PHAC01_Error$$ClearNoCal|
                                  PHAC01_Error$$ColorNoCal);        
        }
	// Return true if error flags contain warnings			
	property hasWarning;
	read: { return f_errors & PHAC01_Error$$PwrCritical; }
	
  /// Return true if any health error was latched
  property hasError;
  read: { return f_errors != 0;  }
  
  /// Return errors as string collection
  property errorStrings;
  read: { return errorsAsStrings(); }
}

/// PHA Color data flags|state helper object
///
object PHAC01_DataFlags
{
  esU32 f_flags;
  
  /// Constructor with assignment
  new( flags )
  {
    f_flags = flags;    
  }
  
  /// Return opmode modifier description as a list of strings
  function ommAsStrings()
  var omm = (f_flags & 0xF0), result = []; 
  { 
    if(PHAC01_OpModeModifier$$None == omm)
      result += PHAC01_OpModeModifier$$None$$label;
    else
    {
      if( omm & PHAC01_OpModeModifier$$BgndTrim )
        result += PHAC01_OpModeModifier$$BgndTrim$$label;
        
      if( omm & PHAC01_OpModeModifier$$Autonomous )
        result += PHAC01_OpModeModifier$$Autonomous$$label;
    }
    
    return result;
  }
  
  /// Return opmode modifiers as string
  function ommAsString()
  {
    return EsStr::fromArray(ommAsStrings(), "; ", "", "");
  }
  
  /// Return data state as a string collection
  function dsAsStrings()
  var ds = (f_flags & 0xF00), result = [];
  {
    if( PHAC01_DataState$$None == ds )
      result += PHAC01_DataState$$None$$label;
    else
    {
      if( ds & PHAC01_DataState$$LowSignal )
        result += PHAC01_DataState$$LowSignal$$label;
    }
    
    return result;
  }
  
  /// Return data state as string
  function dsAsString()
  {
    return EsStr::fromArray(dsAsStrings(), "; ", "", "");
  }
  
  /// Parsed flags properties
  ///
  /// Return sanitized opmode value
  property opmode;
  read: { return (f_flags & 0x0F); } 
  /// Return sanitized opmode value string
  property opmodeStr;
  read: { return PHAC01_OpMode.valueLabelGet( $opmode ); } 
  
  /// Return sanitized opmode modifier
  property opmodeModifier;
  read: { return (f_flags & 0xF0); }
  /// Return sanitized opmode modifier string
  property opmodeModifierStr;
  read: { return ommAsString(); }
  /// Return true if opmode contains BgndTrim modifier
  property isBgndTrimming;
  read: { return f_flags & PHAC01_OpModeModifier$$BgndTrim; }
	/// Return true if opmode contains Autonomous modifier
  property isAutonomous;
  read: { return f_flags & PHAC01_OpModeModifier$$Autonomous; }
  
  /// Return data state
  property dataState;
  read: { return f_flags & 0xF00; }
  /// Return data state string representation
  property dataStateStr;
  read: { return dsAsString(); } 
  
  /// Return data validity flags
  ///
	property valIsValid;
	read: { return 0 == (f_flags & PHAC01_DataInvalid$$val); }
	
	property valOrgIsValid;
	read: { return 0 == (f_flags & PHAC01_DataInvalid$$valOrg); }
	
	property kpIsValid;
	read: { return 0 == (f_flags & PHAC01_DataInvalid$$kp); }
	
	property kpOrgIsValid;
	read: { return 0 == (f_flags & PHAC01_DataInvalid$$kpOrg); }
	
	property kpiIsValid;
	read: { return 0 == (f_flags & PHAC01_DataInvalid$$kpi); }
  
	property kpiOrgIsValid;
	read: { return 0 == (f_flags & PHAC01_DataInvalid$$kpiOrg); }
  
	property bgndIsValid;
	read: { return 0 == (f_flags & PHAC01_DataInvalid$$bgnd); }
  
	property bgndTmoIsValid;
	read: { return 0 == (f_flags & PHAC01_DataInvalid$$bgndTmo); }
  
	property xyIsValid;
	read: { return 0 == (f_flags & PHAC01_DataInvalid$$xy); }
  
 	property ctIsValid;
	read: { return 0 == (f_flags & PHAC01_DataInvalid$$ct); }
}

/// PHA Color data point structure
/// Data interpretation notes:
/// 1) Error flags field duplicated that of device health value
/// 2) Data flags describe device working mode|data fields validity
/// *for instance, mode flag may be set to modeBgnd, then, while validBgnd is not set,
/// bgndTmo is bgnd measurement ETA, in seconds, otherwise, it's duration of bgnd measuement,
/// and bgnd is valid measured bgnd value
///
object PHAC01_Data
{
  /// Data fields
  esDT  f_ts;               ///< Data timestamp
  PHAC01_Health f_errors;   ///< Device error flags
  PHAC01_DataFlags f_flags; ///< Data state|validity flags
  esF   f_val;              ///< Measured value (either illuminance or luminance, depending on mode flag)
  esF   f_valOrg;           ///< Original value (for Bgnd. trimming mode)
  esF   f_kp;               ///< Pulsation coefficient, in %
  esF   f_kpOrg;            ///< Original pulsation coefficient (for Bgnd. trimming mode)
  esF   f_kpi;              ///< Pulsation calculated by integral algo
  esF   f_kpiOrg;           ///< Original pulsation calculated by integral algo
  esF   f_bgnd;             ///< Measured background value (for Bgnd. trimming mode)
  esF   f_x;                ///< CIE x component
  esF   f_y;                ///< CIE y component
  esF   f_ct;               ///< Color temperature in K
  esU16 f_bgndTmo;          ///< Bgnd measurement duration, in seconds
  esU16 f_bgndEta;          ///< Bgnd measurement countdown, in seconds
  
  /// Properties
	///
	/// Timestamp
	property ts;
	read: { return f_ts$value; }
	/// Timestamp string
	property tsStr;
	read: { return f_ts.asString(); }	
	
	/// Errors
	property errors;
	read: { return f_errors; }
	
	/// Data flags
	property flags;
	read: { return f_flags; }
	
  /// Value
  property val;
  read: { return f_val$value; }
	/// Value string components property
	property valStrMulti;
	read: 
	{
    if( PHAC01_OpMode$$Illuminance == f_flags$opmode )  
			return PHAC01_strMultiGet( $val, c_phac01_unitE, f_flags$valIsValid);
		else if( PHAC01_OpMode$$Luminance == f_flags$opmode )
			return PHAC01_strMultiGet( $val, c_phac01_unitL, f_flags$valIsValid);
	}
	/// Value string
	property valStr;
	read: { return PHAC01_fromStrMulti( $valStrMulti ); }
	
  /// Original value
  property valOrg;
  read: { return f_valOrg$value; }
	/// Value string components property
	property valOrgStrMulti;
	read: 
	{
    if( PHAC01_OpMode$$Illuminance == f_flags$opmode )  
			return PHAC01_strMultiGet( $valOrg, c_phac01_unitE, f_flags$valOrgIsValid);
		else if( PHAC01_OpMode$$Luminance == f_flags$opmode )
			return PHAC01_strMultiGet( $valOrg, c_phac01_unitL, f_flags$valOrgIsValid);
	}
	/// Value string
	property valOrgStr;
	read: { return PHAC01_fromStrMulti( $valOrgStrMulti ); }
	
  /// Pulsation (Modulation) coefficient, in %
  property kp;
  read: { return f_kp$value; }
	/// pulsation string components
	property kpStrMulti;
	read: {	return PHAC01_strMultiNoMulPartGet( $kp, c_phac01_unitP, f_flags$kpIsValid ); }
	/// pulsation string
	property kpStr;
  read: { return PHAC01_fromStrMultiNoMulPart( $kpStrMulti ); }  
  
  /// Original Pulsation (Modulation) coefficient, in %
  property kpOrg;
  read: { return f_kpOrg$value; }
	/// pulsation string components
	property kpOrgStrMulti;
	read: {	return PHAC01_strMultiNoMulPartGet( $kpOrg, c_phac01_unitP, f_flags$kpOrgIsValid ); }
	/// pulsation string
	property kpOrgStr;
  read: { return PHAC01_fromStrMultiNoMulPart( $kpOrgStrMulti ); }    
  
  /// Pulsation (Integral) coefficient, in %
  property kpi;
  read: { return f_kpi$value; }
	/// pulsation string components
	property kpiStrMulti;
	read: {	return PHAC01_strMultiNoMulPartGet( $kpi, c_phac01_unitP, f_flags$kpiIsValid ); }
	/// pulsation string
	property kpiStr;
  read: { return PHAC01_fromStrMultiNoMulPart( $kpiStrMulti ); }  
  
  /// Original Pulsation (Integral) coefficient, in %
  property kpiOrg;
  read: { return f_kpiOrg$value; }
	/// pulsation string components
	property kpiOrgStrMulti;
	read: {	return PHAC01_strMultiNoMulPartGet( $kpiOrg, c_phac01_unitP, f_flags$kpiOrgIsValid ); }
	/// pulsation string
	property kpiOrgStr;
  read: { return PHAC01_fromStrMultiNoMulPart( $kpiOrgStrMulti ); }  
  
  /// Measured Background value
  property bgnd;
  read: { return f_bgnd$value; }
	/// Value string components property
	property bgndStrMulti;
	read: 
	{
    if( PHAC01_OpMode$$Illuminance == f_flags$opmode )  
			return PHAC01_strMultiGet( $bgnd, c_phac01_unitE, f_flags$bgndIsValid);
		else if( PHAC01_OpMode$$Luminance == f_flags$opmode )
			return PHAC01_strMultiGet( $bgnd, c_phac01_unitL, f_flags$bgndIsValid);
	}
	/// Value string
	property bgndStr;
	read: { return PHAC01_fromStrMulti( $bgndStrMulti ); } 
  
  /// CIE x component
  property cie_x;
  read: { return f_x$value; }
  /// Value string
  property cie_xStr;
  read: { return PHAC01_CieValueFmt($cie_x, f_flags$xyIsValid); }
  /// Value string components property
  property cie_xStrMulti;
  read: 
  var result = []; 
  { 
    result += $cie_xStr;
    return result; 
   }
  
  /// CIE y component
  property cie_y;
  read: { return f_y$value; }
  /// Value string
  property cie_yStr;
  read: { return PHAC01_CieValueFmt($cie_y, f_flags$xyIsValid); }
  /// Value string components property
  property cie_yStrMulti;
  read: 
  var result = []; 
  { 
    result += $cie_yStr;
    return result; 
  }
  
  /// Correlated color temperature in K
  property cct;
  read: { return f_ct$value; }
  /// Value string components property
  property cctStrMulti;
  read: { return PHAC01_strMultiNoMulPartGet($cct, c_phac01_unitCT, f_flags$ctIsValid); } 
  /// Value string
  property cctStr;
  read: { return PHAC01_fromStrMultiNoMulPart($cctStrMulti); }
  
  /// Background integration (exposure) interval
  property bgndExp;
  read: { return f_bgndTmo$value; }
  
  /// Background integration ETA
	property bgndEta;  
  read: { return f_bgndEta$value; }
    
  /// Overall validation checking
  property valid;
  read:
  {
    if( !f_flags$isBgndTrimming )
    {
      // In this mode we require just value to be valid, at least
      return f_flags$valIsValid;      
    }
    else
    {
      return 0 == f_bgndEta &&
        f_flags$valIsValid &&
        f_flags$valOrgIsValid &&
				f_flags$bgndIsValid &&
				f_flags$bgndTmoIsValid;
    }
  }
  
  /// Parsed Flags properties delegation
  ///
  
  /// Return sanitized opmode value
  property opmode;
  read: { return f_flags$opmode; } 
  /// Return sanitized opmode value string
  property opmodeStr;
  read: { return f_flags$opmodeStr; } 
  
  /// Return sanitized opmode modifier
  property opmodeModifier;
  read: { return f_flags$opmodeModifier; }
  /// Return sanitized opmode modifier string
  property opmodeModifierStr;
  read: { return f_flags$opmodeModifierStr; }
  /// Return true if opmode contains BgndTrim modifier
  property isBgndTrimming;
  read: { return f_flags$isBgndTrimming; }
	/// Return true if opmode contains Autonomous modifier
  property isAutonomous;
  read: { return f_flags$isAutonomous; }
  
  /// Return data state
  property dataState;
  read: { return f_flags$dataState; }
  /// Return data state string representation
  property dataStateStr;
  read: { return f_flags$dataStateStr; } 
  
  /// Return data validity flags
  ///
	property valIsValid;
	read: { return f_flags$valIsValid; }
	
	property valOrgIsValid;
	read: { return f_flags$valOrgIsValid; }
	
	property kpIsValid;
	read: { return f_flags$kpIsValid; }
	
	property kpOrgIsValid;
	read: { return f_flags$kpOrgIsValid; }
	
	property kpiIsValid;
	read: { return f_flags$kpiIsValid; }
  
	property kpiOrgIsValid;
	read: { return f_flags$kpiOrgIsValid; }
  
	property bgndIsValid;
	read: { return f_flags$bgndIsValid; }
  
	property bgndTmoIsValid;
	read: { return f_flags$bgndTmoIsValid; }
  
	property xyIsValid;
	read: { return f_flags$xyIsValid; }
  
 	property ctIsValid;
	read: { return f_flags$ctIsValid; }  
}

/// Raw data structure, used in calibration process
///
object PHAC01_RawData
{
  PHAC01_Health f_errors; ///< Device error flags
  esF   f_val;          ///< Measured raw value (either illuminance or luminance, depending on mode flag)
  esF   f_kp;           ///< Pulsation coefficient, in %
  esF   f_kpi;          ///< Pulsation coefficient, in %
  esU32 f_cntClear;     ///< How many input points were used in clear sensor data calculation
  esF   f_c;            ///< Clear channel of color sensor
  esF   f_r;            ///< Red channel of color sensor
  esF   f_g;            ///< Green channel of color sensor
  esF   f_b;            ///< Blue channel of color sensor
  esU16 f_att;          ///< Currently used attenuation value 1|4|16|256
  esU16 f_cntColor;     ///< How many input points were used to calculate color node  
  
  /// Data access properties
  ///
  /// system error flags
  property errors;
  read: { return f_errors; }
  /// measured clear sensor value
  property val;
  read: { return f_val$value; }
  /// Pulsation (modulation) coefficient, in % 
  property kp;
  read: { return f_kp$value; }
  /// Pulsation (integral) coefficient, in %           
  property kpi;
  read: { return f_kpi$value; }
  /// How many input points were used in clear sensor data calculation
  property cntClear;
  read: { return f_cntClear$value; }
  /// Clear channel of color sensor
  property white;
  read: { return f_c$value; }
  /// Red channel of color sensor
  property red;
  read: { return f_r$value; }
  /// Green channel of color sensor
  property green;
  read: { return f_g$value; }            
  /// Blue channel of color sensor
  property blue;
  read: { return f_b$value; }            
  /// Currently used attenuation value 1|4|16|256
  property att;
  read: { return f_att$value; }
  /// How many input points were used to calculate color node          
  property cntColor;
  read: { return f_cntColor$value; }       
}

/// Matrix structure data 

/// Clear calibration data
object PHAC01_CalibrationClear
{
  EsSpline f_csIllum;    ///< Clear illumination calibration
  EsSpline f_csLum;      ///< Clear luminance calibration
  EsSpline f_csKp;       ///< Clear pulsation calibration  
  
  /// Default constructor
  new()
  {
    f_csIllum$maxLen = 8;
    f_csLum$maxLen = 8;
    f_csKp$maxLen = 8;
  }  
  
  /// Update all crc blocks if needed
  function crcUpdate()
  {
    f_csIllum.crcUpdate();
    f_csLum.crcUpdate();
    f_csKp.crcUpdate();
  }
  
  /// Properties
  ///
  
  /// Return true if all blocks have valid crc
	property crcIsOk;
	read: { return f_csIllum$crcIsOk && f_csLum$crcIsOk && f_csKp$crcIsOk; }
	
  /// Overall validity check
  property valid;
  read: { return f_csIllum$valid && f_csLum$valid && f_csKp$valid; }
  
  /// Illuminance calibration access
  property calIlluminance;
  read: { return f_csIllum; }
  
  /// Luminance calibration access
  property calLuminance;
  read: { return f_csLum; }
  
  /// Pulsation calibration
  property calKp;
  read: { return f_csKp; }
}

/// Color calibration data
object PHAC01_CalibrationColor
{
  var m_acfCrcInvalid;
  
  PHAC01_CorMatrix f_ccm;     ///< XYZ color space correlation matrix
  PHAC01_CorMatrix f_tcm;     ///< Color temperature correlation matrix
  EsSpline f_ccIllum;     ///< Clear channel illumination calibration
  EsSpline f_ccLum;       ///< Clear channel luminosity calibration
  esF f_acf[3];               ///< Color sensor attenuation correction factors for attenuation coefficients > 1
  esU8 f_acfCrc;              ///< ACF vector crc8 field
  
  /// Default constructor
  new()
  {
    m_acfCrcInvalid = true;
    f_ccIllum$maxLen = 8;
    f_ccLum$maxLen = 8;
  }
  
  /// Calculate CRC8 of ACF block
  function acfCrcCalc()
  var crc = new EsCRC8(f_acf#asBinBuffer(), 0xAB);
  {
    return crc;
  }
  
  /// Update ACF block crc if neccessary
  function acfCrcUpdate()
  {
    if( m_acfCrcInvalid )
    {
      f_acfCrc = acfCrcCalc()$value;
      m_acfCrcInvalid = false;
    }
  }
  
  /// Check if CRC of ACF block is OK
  function acfCrcIsOk()
  var crc;
  {
    acfCrcUpdate();
    crc = new EsCRC8(f_acfCrc#asBinBuffer(), f_acfCrc$value);
    return 0 == crc$value;
  }
  
  /// Update CRC of all blocks, if needed
  function crcUpdate()
  {
    f_ccm.crcUpdate();
    f_tcm.crcUpdate();
    f_ccIllum.crcUpdate();
    f_ccLum.crcUpdate();
		acfCrcUpdate();    
  }
  
  /// ACF block item get
  function acfGet(idx)
  {
    return f_acf[idx]$value;
  }
  
  /// ACF block item set
  function acfSet(idx, val)
  {
    f_acf[idx] = val$value;
    m_acfCrcInvalid = true;
  }
 
  /// Properties
  ///
  
  /// Return true if all blocks have valid crc
	property crcIsOk;
	read: 
	{ 
		return acfCrcIsOk() && 
			f_ccm$crcIsOk && f_tcm$crcIsOk &&
       f_ccIllum$crcIsOk && f_ccLum$crcIsOk;
  }
	
	/// Overall validity check
	property valid;
	read: { return f_ccIllum$valid && f_ccLum$valid; }
	
	/// Access Color space Correlation matrix  
  property ccm;
  read: { return f_ccm; }
	
	/// Access Color temperature Correlation matrix  
  property tcm;
  read: { return f_tcm; }
  
  /// Illuminance calibration access
  property calIlluminance;
  read: { return f_ccIllum; }
  
  /// Luminance calibration access
  property calLuminance;
  read: { return f_ccLum; }
}

/// PHAC01 device settings
object PHAC01_Settings
{
  // settings block
  EsFirmwareId f_fwId;
  EsSoftwareInfo f_swInfo;
  
  esU16 f_autosaveInterval;
    @default = PHAC01_Defs$$AutoIntervalDef;
    @restriction = [PHAC01_Defs$$AutoIntervalMin..PHAC01_Defs$$AutoIntervalMax];
  
  esU16 f_bgndExp;
    @default = PHAC01_Defs$$BgndExposureDef;
    @restriction = [PHAC01_Defs$$BgndExposureMin..PHAC01_Defs$$BgndExposureMax];
  
  // Clear calibration data
  PHAC01_CalibrationClear f_calClear;    
  
  // Color calibration data
  PHAC01_CalibrationColor f_calColor;    
  
  /// Constructor
  new(fwId)
  {
    fwIdValidate(fwId, EsDeviceType$$PHAC1, "PHAC01 settings");
    f_fwId.copyFrom(fwId);
  }
}

/// Normal opmode to Legacy opmode converter
function PHAC01_toLegacyOpmode(opmode)
var om = (opmode & 0x0F), omm = (opmode & 0xF0), result = PHAC01_LegacyOpMode$$None;
{
  if(PHAC01_OpMode$$Idle == om)
    result = PHAC01_LegacyOpMode$$Idle;
  else if( PHAC01_OpMode$$Illuminance == om  ||
           PHAC01_OpMode$$Luminance == om )
  {
    if( omm & PHAC01_OpModeModifier$$Autonomous )
      result = PHAC01_LegacyOpMode$$Autonomous;
    else if( omm & PHAC01_OpModeModifier$$BgndTrim )
      result = PHAC01_LegacyOpMode$$LiveWoBgnd;
    else
      result = PHAC01_LegacyOpMode$$Live;
  }
  else if( PHAC01_OpMode$$Oscilloscope == om )
    result = PHAC01_OpMode$$Oscilloscope;
    
  return result;
}

// Legacy opmode to normal opmode converter
function PHAC01_fromLegacyOpmode(legacyOpmode)
var result = PHAC01_OpMode$$None;
{
  if( PHAC01_LegacyOpMode$$Idle == legacyOpmode )
    result = PHAC01_OpMode$$Idle;
  else if( PHAC01_LegacyOpMode$$Live == legacyOpmode )  
    result = PHAC01_OpMode$$Illuminance;
  else if( PHAC01_LegacyOpMode$$Autonomous == legacyOpmode )
    result = PHAC01_OpMode$$Illuminance|PHAC01_OpModeModifier$$Autonomous;
  else if( PHAC01_LegacyOpMode$$LiveWoBgnd == legacyOpmode )
    result = PHAC01_OpMode$$Illuminance|PHAC01_OpModeModifier$$BgndTrim;
  else if( PHAC01_LegacyOpMode$$Oscilloscope == legacyOpmode )
    result = PHAC01_OpMode$$Oscilloscope;
    
  return result;
}

/// PHAC01 device object
object PHAC01 extends EsDeviceBase
@nomarshal;
{
/// Device-specific vars
  var m_opMode;
  
/// Mandatory base overrides
  function rpcNameGetById(rpcId)
  {
    if( rpcId in PHAC01_Rpid )
      return PHAC01_Rpid.valueLabelGet(rpcId);
    
    return EsDeviceBase::rpcNameGetById(rpcId);
  }
  
  function rpcSigGetById(rpcId)
  {
    if( rpcId in PHAC01_Rpid )
      return rpcSigGet(PHAC01_Rpid.valueLabelGet(rpcId));
    
    return EsDeviceBase::rpcSigGetById(rpcId);
  }
  
  function fwIdAssert(fwId)
  {
    EsDeviceBase::fwIdAssert(fwId);
    fwIdValidate(fwId, EsDeviceType$$PHAC1, "PHAC01");
  }

  function fwIdDefaultSet()
  {
    m_fwId = new EsFirmwareId(EsDeviceType$$PHAC1);
    m_fwId.f_serial.f_year = EsDateTime::now()$year;
    m_fwId.f_fwVer.f_major = 1;
    m_fwId.f_fwVer.f_minor = 0;
  }
  
  function rpcCallResultHandle(rpcId, rpcArgs, rpcResult)
  var result = null;
  {
    if( EsRpcStdId$$HEALTH_INFO_GET == rpcId )
      result = new PHAC01_Health(rpcResult);    // use PHAC01 health implementation instead of unparsed standard one
    // Group all simple no-objects responses into one branch
    else if( 
      PHAC01_Rpid$$WorkmodeGet == rpcId ||
      PHAC01_Rpid$$BgndTmoGet == rpcId ||
      PHAC01_Rpid$$AutosaveTmoGet == rpcId ||
      PHAC01_Rpid$$DataCountGet == rpcId ||
      PHAC01_Rpid$$LegacyOperationModeGet == rpcId ||
      PHAC01_Rpid$$LegacyBgndPeriodLeftGet == rpcId ||
      PHAC01_Rpid$$LegacyAutosaveIntervalGet == rpcId
      )
    {
      result = rpcResult;
      
      // in addition, save currently active device opmode
      // it's vital for live data requests handling
      if( PHAC01_Rpid$$LegacyOperationModeGet == rpcId )
        m_opMode = PHAC01_fromLegacyOpmode(result);
      else if( PHAC01_Rpid$$WorkmodeGet == rpcId )
        m_opMode = result;
    }      
    else if( PHAC01_Rpid$$CalibrationClearGet == rpcId )
    {
      result = new PHAC01_CalibrationClear();
      result$buffer = rpcResult#asBinBuffer();
    }
    else if( PHAC01_Rpid$$CalibrationColorGet == rpcId )
    {
      result = new PHAC01_CalibrationColor();
      result$buffer = rpcResult#asBinBuffer();      
    }
    else if( PHAC01_Rpid$$LiveDataGet == rpcId )
    {
      result = new PHAC01_Data(); 
      result$buffer = rpcResult#asBinBuffer();
    }
    else if( PHAC01_Rpid$$RawDataGet == rpcId )
    {
      result = new PHAC01_RawData(); 
      result$buffer = rpcResult#asBinBuffer();
    }
    else if( PHAC01_Rpid$$DataAtIdxGet == rpcId )
    {
      result = new PHAC01_Data();
      result$buffer = rpcResult#asBinBuffer();
    }
    else if( PHAC01_Rpid$$LegacyLiveDataGet == rpcId )
    {
      if( PHAC01_LegacyOpMode$$LiveWoBgnd == PHAC01_toLegacyOpmode(m_opMode) )
        result = new PHAC01_LegacyDataWoBgnd();
      else
        result = new PHAC01_LegacyData();
        
      result$buffer = rpcResult#asBinBuffer();
    }
    else if( PHAC01_Rpid$$LegacyDataAtIdxGet == rpcId )
    {
      result = new PHAC01_LegacyData();
      result$buffer = rpcResult#asBinBuffer();
    }
    else 
      result = EsDeviceBase::rpcCallResultHandle(rpcId, rpcArgs, rpcResult);
    
    return result;
  }
  
  /// Constructors
  new()
  {
    m_opMode = PHAC01_OpMode$$None;
  }
  
  new(fwId)
  {
    m_opMode = PHAC01_OpMode$$None;
  }
  
  /// PHAC01 custom response handlers
  ///
  /// Download settings object
  function settingsDownload()
  var settings = new PHAC01_Settings(m_fwId), rpcResult;
  {
    // Download software info
    rpcResult = rpcCall(EsRpcStdId$$SW_INFO_GET, null);
    if( rpcResult[0] )
      settings.f_swInfo.copyFrom( rpcResult[1] );
    else
      return rpcResult;
    
    rpcResult = rpcCall(PHAC01_Rpid$$AutosaveTmoGet, null);
    if( rpcResult[0] )
      settings.f_autosaveInterval = rpcResult[1];
    else
      return rpcResult;
      
    rpcResult = rpcCall(PHAC01_Rpid$$BgndTmoGet, null);
    if( rpcResult[0] )
      settings.f_bgndExp = rpcResult[1];
    else
      return rpcResult;      
      
    rpcResult = rpcCall(PHAC01_Rpid$$CalibrationClearGet, null);
    if( rpcResult[0] )
      settings.f_calClear.copyFrom( rpcResult[1] );
    else
      return rpcResult;
    
    rpcResult = rpcCall(PHAC01_Rpid$$CalibrationColorGet, null);
    if( rpcResult[0] )
      settings.f_calColor.copyFrom( rpcResult[1] );
    else
      return rpcResult;
    
    rpcResult = [];
    rpcResult += true;
    rpcResult += settings;
    
    return rpcResult;
  }
	
  /// Upload settings object
  function settingsUpload(settings)
  var batch = [], batchItem = [];
  {
    if( settings.f_fwId != m_fwId )
      throw "Could not upload incompatible device settings";
    
    batchItem += PHAC01_Rpid$$AutosaveTmoSet;
    batchItem += settings.f_autosaveInterval;
    batch#append(batchItem);
    batchItem = [];
    
    batchItem += PHAC01_Rpid$$BgndTmoSet;
    batchItem += settings.f_bgndExp;
    batch#append(batchItem);
    batchItem = [];
        
    batchItem += PHAC01_Rpid$$CalibrationClearSet;
    batchItem += settings.f_calClear;
    batch#append(batchItem);
    batchItem = [];
    
    batchItem += PHAC01_Rpid$$CalibrationColorSet;
    batchItem += settings.f_calColor;
    batch#append(batchItem);
    batchItem = [];
    
    batch = rpcBatchCall(batch);
    // We're not interested in returning entire batch result.
    // just treat batch results as a whole.
    if( deviceCheckBatchResultOk(batch) )
    {
      batchItem += true;
      batchItem += null; // nothing is returned
    }
    else
    {
      batchItem += false;
      batchItem += "Device settings upload fail";
    }

    return batchItem;
  }
	
	/// Properties
	///
	/// Currently active opmode
	property opmode;
	read: { return m_opMode; }
	
	/// Opmode string
	property opmodeStr;
	read:
	var helper = new PHAC01_DataFlags(m_opMode);
	{ 
		return m_opMode;
	}
}
