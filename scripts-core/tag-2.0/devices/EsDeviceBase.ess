/// @file EsDeviceBase.ess
/// Ekosf device framework base object && stuff

##require("core.ess");

/// Device event structure is as follows:
///	evt_id=<some Id>, payload=deviceFwId<,payload>
///		payload = Change|RPC (batch) request|RPC (batch) response|custom request|custom response
///     Change=[changed value property name, changed value property name, ... , changed value property name]
///     RPC response (batch) = RPC request (batch) parameters, RPC response (batch) data
///     RPC request = [rpcId, args]
///     RPC request (batch) = [[rpcId 0, args 0], ... [rpcId N, args N]]
///     RPC response data = [true|false, data]
///     RPC response (batch) data = [[true|false, data 0], ... [true|false, data N]]
///     	true =	response succeeded, false - otherwise
///       				if true - data = response data, if false data = error reason
///     Custom request = [procName, args]
///     Custom response = [true|false, data]
///

/// Device event Ids
enum EsDeviceEvtId {
  idChanged       = 1000, "Device FW ID changed";
  ioStateChanged  = 1001, "Device IO state changed";
  rpcRequest      = 1002, "Queued RPC request";
  rpcRequestBatch  = 1003, "Queued batch RPC request";
  rpcResponse      = 1004, "Device responded to RPC request";
  rpcResponseBatch = 1005, "Device responded to RPC batch request";
  payloadChanged  = 1006, "Device payload contents changed";
  customRequest    = 1007, "Custom device request";
  customResponse  = 1008, "Response to the custom request";
}

/// Base object for every device, like pha01, boi01, etc.
/// Any derived device object must override the following base methods:
/// -function rpcNameGetById(rpcId)
/// -function rpcSigGetById(rpcId)
/// -function fwIdAssert(fwId)
/// -function fwIdDefaultSet()
/// -function rpcCallResultHandle(rpcId, rpcArgs, rpcResult)
/// Optionally overridden may be:
/// -function evtHandle(m_ioMaster, evtId, payload)
/// Any derived device may optionally implement custom response functions
/// Result returned from custom response functions should comply with 
/// the standard RPC response structure: [true|false, data]
///
object EsDeviceBase
{
  var m_fwInitialized,
/// Device id. Null, if never identified
    m_fwId,
/// Device RPC capabilities. Null, if never contacted     
    m_caps,
    
/// IO master currently used for communications
    m_ioMaster,
/// Temporary - cached fwId string
    m_tmpFwIdStr,

/// IO state block
    m_ioSuccessTs,  /// > Last successfull io attempt timestamp, 0 if never contacted
    m_ioAttemptTs,  /// > Last io attempt timestamp, 0 if never contacted
    m_ioErrorCount,  /// > Count of io errors since last successfull communication attempt. if 0 - consider device alive and well
    m_ioAddr,        /// > Device protocol address. 255 (broadcast) by default
    m_ioErrorLog,  /// > Last IO error string

/// Arbitrary user-defined device payload data
    m_payload;
      
/// Methods:
///
/// Post device-specific event
  function evtPost(cat, id, data)
  var payload = [];
  {
    payload += m_tmpFwIdStr;
    if( !data#isEmpty() )
      payload#append(data);
      
    __scriptHost.eventPost(cat, id, payload);
  }
	
/// Push response to the dispatcher queue
  function evtResponsePost(responseId, request, response)
  var responseData = [];
  {
    responseData#append(request);
    responseData#append(response);
    evtPost("fromDevice", responseId, responseData);
  }
	
/// Return user-friendly RPC name string, or 'Unknown RPC with <id>'.
/// By default, handles only the standard RPC ids, derived objects must extend this functionality
  function rpcNameGetById(rpcId)
  {  
    if( rpcId in EsRpcStdId )
      return EsRpcStdId.valueLabelGet(rpcId);
    
    return EsStr::format("Unknown RPC id: '%d'", rpcId);
  }
	
/// Return RPC signature string, or throws 'Unsupported RPC with <id>'.
/// By default, handles only the standard RPC ids, derived objects must extend this functionality
  function rpcSigGetById(rpcId)
  {  
    if( rpcId in EsRpcStdId )
      return rpcSigGet(EsRpcStdId.valueLabelGet(rpcId));
    
    throw EsStr::format("Unsupported RPC id: '%d'", rpcId);
  }
	
/// Reset io state block
  function ioStateReset()
  {
    m_ioSuccessTs = new EsDateTime();
    m_ioAttemptTs = new EsDateTime();
    m_ioErrorCount = 0;
    m_ioAddr = 255;
    m_ioErrorLog = [];
  }
	
/// fwId assertion. Base implementation just checks for null and properly typed argument, 
/// must be overridden in derived objects
  function fwIdAssert(fwId)
  {
    if( fwId#isEmpty() )
      throw "Could not assign empty value to firmware Id";
    
    if( !fwId#isObject() || !fwId.isKindOf("EsFirmwareId") )
      throw "Could not assign argument of wrong type to firmware Id";
  }
	
/// Assign fwId to device  
  function fwIdSet(fwId)
  {
    fwIdAssert(fwId);
    if( fwId != m_fwId ) // significant differences in fwId
    {
      if( m_fwInitialized )
        throw "Could not re-assign firmware id to existing device";
        
      m_fwId = fwId;
      m_tmpFwIdStr = m_fwId.asString();
      m_fwInitialized = true;
      evtPost("fromDevice", EsDeviceEvtId$$idChanged, null);
    }
    else if( m_fwId.asString() != fwId.asString() ) // insignificant differences
    {
      m_fwId = fwId;
      m_tmpFwIdStr = m_fwId.asString();
      m_fwInitialized = true;
      evtPost("fromDevice", EsDeviceEvtId$$idChanged, null);
    }
  }
	
/// Assign default FW id to the device. Must be overridden in derived classes
  function fwIdDefaultSet()
  {
    throw "fwIdDefaultSet must be overridden!";
  }
	
/// Address check
  function addrAssert(addr)
  {
    if( !(addr in [0 .. 254]) )
      throw "Device address value is out of range";
  }
	
/// Assign address
  function addrSet(addr)
  {
    addr = addr.asULong();
    addrAssert( addr );
    if( m_ioAddr != addr )
    {
      m_ioAddr = addr;
      evtPost("fromDevice", EsDeviceEvtId$$ioStateChanged, "ioAddr");
    }
  }
	
/// IO attempt handler
  function onIoAttempt()
  {
    m_ioAttemptTs = EsDateTime::now();
  }
	
/// IO success condition handler
  function onIoSuccess()
  var change = [];
  {
    m_ioSuccessTs = EsDateTime::now();
    m_ioErrorCount = 0;
    m_ioErrorLog = [];
    // post event with changes
    change += "ioSuccessTs";
    change += "ioAttemptTs";
    change += "ioErrorCount";
    change += "ioLastError";
    evtPost("fromDevice", EsDeviceEvtId$$ioStateChanged, change);
  }
	
/// IO error condition handler
  function onIoError(error)
  var change = [];
  {
    ++m_ioErrorCount;
    m_ioErrorLog += error.asString();
    // post event with changes
    change += "ioAttemptTs";
    change += "ioErrorCount";
    change += "ioLastError";
    evtPost("fromDevice", EsDeviceEvtId$$ioStateChanged, change);
  }
	
/// Common initializer
  function internalInit()
  {
    m_tmpFwIdStr = "";
    ioStateReset();
  }
	
/// Constructor
  new()
  {
    m_fwInitialized = false;
    internalInit();
    fwIdDefaultSet();
  }
	
  new( fwId )
  {
    m_fwInitialized = false;    
    internalInit();
    fwIdSet(fwId);
  }  
	
/// rpcCall result handler. Base functionality - handles the most basic
/// stuff which must always be there. handlingResult parameter is reserved for override calls.
/// Inherited objects must first do their own handling, then call base object method, passing processing result in
/// handlingResult parameter. Top call should always set this parameter to null
  function rpcCallResultHandle(rpcId, rpcArgs, rpcResult)
  var handlingResult = null;
  {
    if( !rpcResult#isEmpty() )
    {
      // handle standard data requests
      // NB! health info query response, included here, should normally be overridden in derived devices
      // to return helth info object instead.
      if(EsRpcStdId$$HW_UID_GET == rpcId)
      {
        handlingResult = new EsDeviceUID();
        handlingResult$buffer = rpcResult;
      }
      else if(EsRpcStdId$$HW_INFO_GET == rpcId && rpcResult#countGet() )
      {
        handlingResult = new EsDeviceHwInfo();
        handlingResult$buffer = rpcResult;
      }
      else if(EsRpcStdId$$SW_INFO_GET == rpcId && rpcResult#countGet() )
      {
        handlingResult = new EsSoftwareInfo();
        handlingResult$buffer = rpcResult;
      }
      else if(EsRpcStdId$$POWER_STATUS_GET == rpcId && rpcResult#countGet() )
      {
        handlingResult = new EsPowerStatus();
        handlingResult$buffer = rpcResult;
      }
			else if(EsRpcStdId$$FS_FREESPACE_GET == rpcId && rpcResult#countGet())
			{
				handlingResult = new EsFsSpaceInfoResult();
				handlingResult$buffer = rpcResult;
			}
			else if(EsRpcStdId$$DIR_LIST_NEXT_GET == rpcId )
			{
				if( rpcResult#countGet() == 2 )
					handlingResult = rpcResult#asUInt();
				else
				{
					handlingResult = new EsFsItemResult();
					handlingResult$buffer = rpcResult;
				}
			}
			else if(EsRpcStdId$$FILE_READ_START == rpcId && rpcResult#countGet())
			{
				handlingResult = new EsFsFileReadRequest();
				handlingResult$buffer = rpcResult;
			}
			else if(EsRpcStdId$$DIR_LIST_START == rpcId ||
							EsRpcStdId$$DIR_DELETE == rpcId ||
							EsRpcStdId$$FILE_DELETE == rpcId )
				handlingResult = rpcResult#asUInt();
      else // return raw rpc response by default
        handlingResult = rpcResult;
    }
    
    return handlingResult;
  }
	
/// RPC pre-call filtering helper. If device capabilities were requested, and m_caps not empty,
/// check rpcId against m_caps before actuall call, and throw 'unsupported RPC' without actually 
/// performing any io transaction
	function rpcCapsAssert(rpcId)
	{
		if( !m_caps#isEmpty() && !(rpcId in m_caps) )
			throw EsStr::format("RPC with id: %d (%s) is not supported on '%s'", rpcId, rpcNameGetById(rpcId), m_tmpFwIdStr);
	}
	
/// Parametric RPC call. Returned is pair [true|false, result], true, if call was successfull, false otherwise
/// result contains the optional return value of rpcCallResultHandle
  function rpcCall(rpcId, rpcArgs)
  var result, tmp = [];
  {
    // 1) check if m_ioMaster is not null and active
    rpcMasterAssert(m_ioMaster);
		// assert RPC id
		rpcCapsAssert(rpcId);
    // 2) create try-catch scope
    try
    {
      // 3) lock m_ioMaster
      m_ioMaster.lock();
      // assign io address
      m_ioMaster$clientAddr = m_ioAddr;
      // call io attempt handler
      onIoAttempt();
      // 4) perform rpc call
      if( EsRpcStdId$$CAPS_GET == rpcId )
      {
        result = m_ioMaster.getImplementedRPCs();
        m_caps = result;
      }
      else
        result = m_ioMaster.callMethod(rpcSigGetById(rpcId), rpcId, rpcArgs);
      // call io success handler
      onIoSuccess();
      // 5) handle its result - call result handler, if registered for rpcId
      result = rpcCallResultHandle(rpcId, rpcArgs, result);
      // restore broadcast address
      m_ioMaster$clientAddr = 255;
      // 7) unlock m_ioMaster
      m_ioMaster.unlock();
      tmp += true; tmp += result;
    }
    catch
    {
      // 6) handle error
      onIoError(__exception$reason);
      // restore broadcast address
      m_ioMaster$clientAddr = 255;
      // 7) unlock m_ioMaster
      m_ioMaster.unlock();
      tmp += false; tmp += __exception$reason;
    }

    return tmp;
  }
	
/// Batch item checking
  function batchItemAssert(batchItem)
  {
    if( batchItem#isEmpty() )
      throw "Device io batch item must not be empty";

    if( !batchItem#isIndexed() )
      throw "Device io batch item must be of indexed type";
    
    if( 2 != batchItem.countGet() )
      throw "Wrong device io batch item member count.";
  }
	
/// Batch io call service. It's expecting collection of input arrays: [rpcId, args]
/// as 'batch' argument. Returned is the collection of pairs [true|false, stepResult] 
/// The first pair member is true, if no errors occurred during batch execution.
/// Otherwise, the first pair member is false.
  function rpcBatchCall(batch)
  var batchResult = [], tmp, result, batchItem, rpcId, rpcArgs;
  {
    // 1) check if m_ioMaster is not null and active
    rpcMasterAssert(m_ioMaster);
    // 2) create try-catch scope
    try
    {
      // 3) lock m_ioMaster
      m_ioMaster.lock();
      // assign io address
      m_ioMaster$clientAddr = m_ioAddr;
      // iterate batch
      foreach(batchItem in batch)
      {
        // assert batch item structure
        batchItemAssert(batchItem);
        // call io attempt handler
        onIoAttempt();
        // 4) perform rpc call
        rpcId = batchItem[0];
				// assert RPC id
				rpcCapsAssert(rpcId);
        rpcArgs = batchItem[1];
        if( EsRpcStdId$$CAPS_GET == rpcId )
        {
          result = m_ioMaster.getImplementedRPCs();
          m_caps = result;
        }  
        else
          result = m_ioMaster.callMethod(rpcSigGetById(rpcId), rpcId, rpcArgs);
        // call io success handler
        onIoSuccess();
        // 5) handle its result - call result handler, if registered for rpcId
        result = rpcCallResultHandle(rpcId, rpcArgs, result);
   
        tmp = [];
        tmp += true; tmp += result;
        batchResult#append(tmp);
      }
      // restore broadcast address
      m_ioMaster$clientAddr = 255;
      // 7) unlock m_ioMaster
      m_ioMaster.unlock();
    }
    catch
    {
      // 6) handle error
      onIoError(__exception$reason);
      // restore broadcast address
      m_ioMaster$clientAddr = 255;
      // 7) unlock m_ioMaster
      m_ioMaster.unlock();
      // create result pair
      tmp = [];
      tmp += false; tmp += __exception$reason;
      batchResult#append(tmp);
    }
    
    return batchResult;
  }
	
/// Handle -to device event. Default implementation handles
/// single, batch, and custom requests
  function evtDestAssert(devIdStr)
  {
    if( "all" != devIdStr && m_tmpFwIdStr != devIdStr )
      throw "Event mistakenly dispatched to the wrong device";
  }

  function evtHandle(evtId, evtPayload)
  var result, request, devIdStr = evtPayload[0];
  {
    evtDestAssert(devIdStr);
    
    if( EsDeviceEvtId$$rpcRequest == evtId )
    {
      request = evtPayload[1];
      result = rpcCall(request[0], request[1]);
      evtResponsePost(EsDeviceEvtId$$rpcResponse, request, result);
    }
    else if( EsDeviceEvtId$$rpcRequestBatch == evtId )
    {
      request = evtPayload[1];
      result = rpcBatchCall(request);
      evtResponsePost(EsDeviceEvtId$$rpcResponseBatch, request, result);
    }
    else if( EsDeviceEvtId$$customRequest == evtId )
    {
      request = evtPayload[1];
      result = callMethod(request[0], request[1]);
      evtResponsePost(EsDeviceEvtId$$customResponse, request, result);
    }
  }
	
/// Custom request handlers to simplify RPC FS operations
///
/// Internal fsresult substitution helper. Must not be used directly
	function checkFsResultOnSuccess( result )
	{
		if( result[0] && EsFsResult$$OK != result[1] )
		{
			result[0] = false;
			result[1] = fsResultStringGet(result[1]);
		}
		
		return result;
	}
	
/// Start listing objects in specified 'pathAbs' (must be absolute path) directory
	function dirListStart(dirAbsPath)
	var result, bs = EsStr::toByteString(dirAbsPath);
	{
		// send zero-terminated buffer, including terminating 0
		bs += B'\0';
		result = rpcCall(EsRpcStdId$$DIR_LIST_START, bs);
		result = checkFsResultOnSuccess( result );
		
		return result;
	}

/// Proceed with directory listing, started by 'dirListStart' call
/// If directory contains no more entries, the call returns [true, null]
/// Otherwise, [true, <current EsFsItem>] is returned
	function dirListGetNextItem()
	var buff, fsResult, result = rpcCall(EsRpcStdId$$DIR_LIST_NEXT_GET, null);
	{
		if( result[0] )
		{
			fsResult = result[1];
			if( !fsResult#isObject() )
			{
				if( EsFsResult$$OK != fsResult )
				{
					result[0] = false;
					result[1] = fsResultStringGet(fsResult);
				}
				else
					result[1] = null;
			}
			else
			{
				// return 'prepared' EsFsItem object, instead of 'compound' EsFsItemResult
				result[1] = new EsFsItem();
				result[1].copyFrom(fsResult.f_item);
			}
		}
		 
		return result;
	}

/// Directory deletion service. If 'force' is true, tries to delete all directory content, if any.
/// Otherwise, aborts deletion if directory is not empty.
	function dirDelete(dirAbsPath, force)
	var bs = EsStr::toByteString(dirAbsPath), args = [], result;
	{
		// send zero-terminated buffer, including terminating 0
		bs += B'\0';	
		args += bs;
		args += force;
		result = rpcCall(EsRpcStdId$$DIR_DELETE, args);
		result = checkFsResultOnSuccess( result );
		
		return result;
	}
	
/// File deletion service.
	function fileDelete(fileAbsPath)
	var bs = EsStr::toByteString(fileAbsPath), result;
	{
		// send zero-terminated buffer, including terminating 0
		bs += B'\0';
		result = rpcCall(EsRpcStdId$$FILE_DELETE, bs);
		result = checkFsResultOnSuccess( result );
		
		return result;
	}

/// Free filesystem information query service.
	function fileSysFreeSpaceInfoGet()
	var result = rpcCall(EsRpcStdId$$FS_FREESPACE_GET, null), infoResult;
	{
		if( result[0] )
		{
			infoResult = result[1];
			if( EsFsResult$$OK != infoResult.f_result )
			{
				result[0] = false;
				result[1] = fsResultStringGet(infoResult.f_result);
			}
			else
			{
				// return 'prepared' EsFsSpaceInfo object instead of 'compound' EsFsSpaceInfoResult
				result[1] = new EsFsSpaceInfo();
				result[1].copyFrom(infoResult.f_info);
			}
		}
			
		return result;
	}

	/// File read service. May perform multiple calls to the low-level RPC
	/// file read services. Return entire file as binary buffer.
	function fileRead(fileAbsPath)
	var bs = EsStr::toByteString(fileAbsPath), fsResult, 
			f = EsVar::as(EsVariantType$$VAR_BIN_BUFFER), 
			chunks, chunk, result;
	{
		// send zero-terminated buffer, including terminating 0
		bs += B'\0';
		result = rpcCall(EsRpcStdId$$FILE_READ_START, bs);
		if( result[0] )
		{
			// todo: notify file read start action
			fsResult = result[1];
			if( EsFsResult$$OK != fsResult.f_result )
			{
				result[0] = false;
				result[1] = fsResultStringGet(fsResult.f_result);
				
				// todo: notify action end with error
			}
			else
			{
				chunks = fsResult.f_chunks;
				chunk = 0;
				// todo: re-notify file read start action with known range now
				while( result[0] && chunk < chunks )
				{
					result = rpcCall(EsRpcStdId$$FILE_READ_NEXT, null);
					if( result[0] )
					{
						f += result[1];
						// todo: notify action progress
					}
					++chunk;
				}
				
				if( result[0] )
				{
					// todo: notify file read action end OK
					result[1] = f;
				}
				else
				{
					// todo: notify file read action end with error
					result[1] = null;
				}
			}
		}
		
		return result;
	}
  
/// Properties:
///   
/// Currently used io master. Must be set to null when device goes inactive.
/// Must be re-assigned (by branch, or whatever) when device goes active
  property ioMaster;
  write: { m_ioMaster = __value; }

/// Read-only access to the device fwid string
  property fwIdStr;
  read: { return m_tmpFwIdStr; }
	
/// Read-only access to the device fwid
  property fwId;
  read: var tmp = new EsFirmwareId(); { 
    tmp.copyFrom(m_fwId);
    return tmp;
  }
	
/// Read-only access to actual (downloaded from physical device itself) capabilities
  property caps;
  read: { return m_caps; }
	
/// Return last successful IO timestamp
  property ioSuccessTs;
  read: { return m_ioSuccessTs; }
	
/// Return last IO attempt timestamp
  property ioAttemptTs;
  read: { return m_ioAttemptTs; }
	
/// Return current count of IO attempt errors
  property ioErrorCount;
  read: { return m_ioErrorCount.asULong(); }
	
/// Return currently set io address
  property ioAddr;
  read: { return m_ioAddr.asULong(); }
	
/// Return error log collection, if any
  property ioErrorLog;
  read: { return m_ioErrorLog; }
	
/// Payload access
  property payload;
  read: { return m_payload; }
  write: { 
    m_payload = __value;
    evtPost("fromDevice", EsDeviceEvtId$$payloadChanged, "payload");
  }
}

/// Return true if batch results are all OK,
/// false otherwise
function deviceCheckBatchResultOk(batchResult)
var batchItem;
{
  if( batchResult#isEmpty() || !batchResult#countGet() )
    return false;
  
  foreach( batchItem in batchResult )
    if( !batchItem[0] )
      return false;
      
  return true;
}

/// Try to read and return device firmware id object
function deviceFwIdRead(rpcMaster)
var fwId, rpcResult = rpcMaster.BYTEARRAY_Call(EsRpcStdId$$FWID_GET);
{
  if( !rpcResult#isEmpty() )
  {
    fwId = new EsFirmwareId();
    fwId$buff = rpcResult#asBinBuffer();
  }
  
  return fwId;
}
