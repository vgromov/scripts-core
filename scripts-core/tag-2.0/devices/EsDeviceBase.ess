/// @file EsDeviceBase.ess
/// Ekosf device framework base object && stuff

##require("core.ess");

/// Device event structure is as follows:
///  evt_id=<some Id>, payload=deviceFwId<,payload>
///    payload = Change|RPC (batch) request|RPC (batch) response|custom request|custom response
///     Change=[changed value property name, changed value property name, ... , changed value property name]
///     RPC response (batch) = RPC request (batch) parameters, RPC response (batch) data
///     RPC request = [rpcId, args]
///     RPC request (batch) = [[rpcId 0, args 0], ... [rpcId N, args N]]
///     RPC response data = [true|false, data]
///     RPC response (batch) data = [[true|false, data 0], ... [true|false, data N]]
///       true =  response succeeded, false - otherwise
///               if true - data = response data, if false data = error reason
///     Custom request = [procName, args]
///     Custom response = [true|false, data]
///

/// Device event Ids
enum EsDeviceEvtId {
  idChanged       = 1000, "Device FW ID changed";
  ioStateChanged  = 1001, "Device IO state changed";
  rpcRequest      = 1002, "Queued RPC request";
  rpcRequestBatch  = 1003, "Queued batch RPC request";
  rpcResponse      = 1004, "Device responded to RPC request";
  rpcResponseBatch = 1005, "Device responded to RPC batch request";
  payloadChanged  = 1006, "Device payload contents changed";
  customRequest    = 1007, "Custom device request";
  customResponse  = 1008, "Response to the custom request";
}

/// Base object for every device, like pha01, boi01, etc.
/// Any derived device object must override the following base methods:
/// -function rpcNameGetById(rpcId)
/// -function rpcSigGetById(rpcId)
/// -function fwIdAssert(fwId)
/// -function fwIdDefaultSet()
/// -function rpcCallResultHandle(rpcId, rpcArgs, rpcResult)
/// Optionally overridden may be:
/// -function evtHandle(m_ioMaster, evtId, payload)
/// Any derived device may optionally implement custom response functions
/// Result returned from custom response functions should comply with 
/// the standard RPC response structure: [true|false, data]
///
object EsDeviceBase
{
  var m_fwInitialized,
/// Device id. Null, if never identified
    m_fwId,
/// Device RPC capabilities. Null, if never contacted     
    m_caps,
    
/// IO master currently used for communications
    m_ioMaster,
/// Temporary - cached fwId string
    m_tmpFwIdStr,

/// IO state block
    m_ioSuccessTs,  /// > Last successfull io attempt timestamp, 0 if never contacted
    m_ioAttemptTs,  /// > Last io attempt timestamp, 0 if never contacted
    m_ioErrorCount,  /// > Count of io errors since last successfull communication attempt. if 0 - consider device alive and well
    m_ioAddr,        /// > Device protocol address. 255 (broadcast) by default
    m_ioErrorLog,  /// > Last IO error string

/// Arbitrary user-defined device payload data
    m_payload;
      
/// Methods:
///
/// Post device-specific event
  function evtPost(cat, id, data)
  var payload = [];
  {
    payload += m_tmpFwIdStr;
    if( !data#isEmpty() )
      payload#append(data);
      
    __scriptHost.eventPost(cat, id, payload);
  }
  
/// Push response to the dispatcher queue
  function evtResponsePost(responseId, request, response)
  var responseData = [];
  {
    responseData#append(request);
    responseData#append(response);
    evtPost("fromDevice", responseId, responseData);
  }
  
/// Return user-friendly RPC name string, or 'Unknown RPC with <id>'.
/// By default, handles only the standard RPC ids, derived objects must extend this functionality
  function rpcNameGetById(rpcId)
  {  
    if( rpcId in EsRpcStdId )
      return EsRpcStdId.valueLabelGet(rpcId);
    
    return EsStr::format("Unknown RPC id: '%d'", rpcId);
  }
  
/// Return RPC signature string, or throws 'Unsupported RPC with <id>'.
/// By default, handles only the standard RPC ids, derived objects must extend this functionality
  function rpcSigGetById(rpcId)
  {  
    if( rpcId in EsRpcStdId )
      return rpcSigGet(EsRpcStdId.valueLabelGet(rpcId));
    
    throw EsStr::format("Unsupported RPC id: '%d'", rpcId);
  }
  
/// Reset io state block
  function ioStateReset()
  {
    m_ioSuccessTs = new EsDateTime();
    m_ioAttemptTs = new EsDateTime();
    m_ioErrorCount = 0;
    m_ioAddr = 255;
    m_ioErrorLog = [];
  }
  
/// fwId assertion. Base implementation just checks for null and properly typed argument, 
/// must be overridden in derived objects
  function fwIdAssert(fwId)
  {
    if( fwId#isEmpty() )
      throw "Could not assign empty value to firmware Id";
    
    if( !fwId#isObject() || !fwId.isKindOf("EsFirmwareId") )
      throw "Could not assign argument of wrong type to firmware Id";
  }
  
/// Assign fwId to device  
  function fwIdSet(fwId)
  {
    fwIdAssert(fwId);
    if( fwId != m_fwId ) // significant differences in fwId
    {
      if( m_fwInitialized )
        throw "Could not re-assign firmware id to existing device";
        
      m_fwId = fwId;
      m_tmpFwIdStr = m_fwId.asString();
      m_fwInitialized = true;
      evtPost("fromDevice", EsDeviceEvtId$$idChanged, null);
    }
    else if( m_fwId.asString() != fwId.asString() ) // insignificant differences
    {
      m_fwId = fwId;
      m_tmpFwIdStr = m_fwId.asString();
      m_fwInitialized = true;
      evtPost("fromDevice", EsDeviceEvtId$$idChanged, null);
    }
  }
  
/// Assign default FW id to the device. Must be overridden in derived classes
  function fwIdDefaultSet()
  {
    throw "fwIdDefaultSet must be overridden!";
  }
  
/// Address check
  function addrAssert(addr)
  {
    if( !(addr in [0 .. 254]) )
      throw "Device address value is out of range";
  }
  
/// Assign address
  function addrSet(addr)
  {
    addr = addr.asULong();
    addrAssert( addr );
    if( m_ioAddr != addr )
    {
      m_ioAddr = addr;
      evtPost("fromDevice", EsDeviceEvtId$$ioStateChanged, "ioAddr");
    }
  }
  
/// IO attempt handler
  function onIoAttempt()
  {
    m_ioAttemptTs = EsDateTime::now();
  }
  
/// IO success condition handler
  function onIoSuccess()
  var change = [];
  {
    m_ioSuccessTs = EsDateTime::now();
    m_ioErrorCount = 0;
    m_ioErrorLog = [];
    // post event with changes
    change += "ioSuccessTs";
    change += "ioAttemptTs";
    change += "ioErrorCount";
    change += "ioLastError";
    evtPost("fromDevice", EsDeviceEvtId$$ioStateChanged, change);
  }
  
/// IO error condition handler
  function onIoError(error)
  var change = [];
  {
    ++m_ioErrorCount;
    m_ioErrorLog += error.asString();
    // post event with changes
    change += "ioAttemptTs";
    change += "ioErrorCount";
    change += "ioLastError";
    evtPost("fromDevice", EsDeviceEvtId$$ioStateChanged, change);
  }
  
/// Common initializer
  function internalInit()
  {
    m_tmpFwIdStr = "";
    ioStateReset();
  }
  
/// Constructor
  new()
  {
    m_fwInitialized = false;
    internalInit();
    fwIdDefaultSet();
  }
  
  new( fwId )
  {
    m_fwInitialized = false;    
    internalInit();
    fwIdSet(fwId);
  }  
  
/// rpcCall result handler. Base functionality - handles the most basic
/// stuff which must always be there. handlingResult parameter is reserved for override calls.
/// Inherited objects must first do their own handling, then call base object method, passing processing result in
/// handlingResult parameter. Top call should always set this parameter to null
  function rpcCallResultHandle(rpcId, rpcArgs, rpcResult)
  var handlingResult;
  {
    if( !rpcResult#isEmpty() )
    {
      // handle standard data requests
      // NB! health info query response, included here, should normally be overridden in derived devices
      // to return helth info object instead.
      if(EsRpcStdId$$HW_UID_GET == rpcId)
      {
        handlingResult = new EsDeviceUID();
        handlingResult$buffer = rpcResult;
      }
      else if(EsRpcStdId$$HW_INFO_GET == rpcId && rpcResult#countGet() )
      {
        handlingResult = new EsDeviceHwInfo();
        handlingResult$buffer = rpcResult;
      }
      else if(EsRpcStdId$$SW_INFO_GET == rpcId && rpcResult#countGet() )
      {
        handlingResult = new EsSoftwareInfo();
        handlingResult$buffer = rpcResult;
      }
      else if(EsRpcStdId$$POWER_STATUS_GET == rpcId && rpcResult#countGet() )
      {
        handlingResult = new EsPowerStatus();
        handlingResult$buffer = rpcResult;
      }
      else if(EsRpcStdId$$FS_FREESPACE_GET == rpcId && rpcResult#countGet())
      {
        handlingResult = new EsFsSpaceInfoResult();
        handlingResult$buffer = rpcResult;
      }
      else if(EsRpcStdId$$DIR_LIST_NEXT_GET == rpcId )
      {
        if( rpcResult#countGet() == 2 )
          handlingResult = rpcResult#asULong();
        else
        {
          handlingResult = new EsFsItemResult();
          handlingResult$buffer = rpcResult;
        }
      }
      else if(EsRpcStdId$$FILE_READ_START == rpcId && rpcResult#countGet())
      {
        handlingResult = new EsFsFileReadRequest();
        handlingResult$buffer = rpcResult;
      }
      else if(EsRpcStdId$$DIR_LIST_START == rpcId ||
              EsRpcStdId$$DIR_DELETE == rpcId ||
              EsRpcStdId$$FILE_DELETE == rpcId )
        handlingResult = rpcResult#asULong();
      else // return raw rpc response by default
        handlingResult = rpcResult;
    }
    
    return handlingResult;
  }
  
/// RPC pre-call filtering helper. If device capabilities were requested, and m_caps not empty,
/// check rpcId against m_caps before actuall call, and throw 'unsupported RPC' without actually 
/// performing any io transaction
  function rpcCapsAssert(rpcId)
  {
    if( !m_caps#isEmpty() && !(rpcId in m_caps) )
      throw EsStr::format("RPC with id: %d (%s) is not supported on '%s'", rpcId, rpcNameGetById(rpcId), m_tmpFwIdStr);
  }
  
/// Internal io master call helper. Must not be called directly.  
  function internalCallMaster(rpcId, rpcArgs)
  var args = [];
  {
    args += rpcId;
    if( !rpcArgs#isEmpty() )
      args += rpcArgs;
    
    return m_ioMaster.callMethod(rpcSigGetById(rpcId), args);
  }
  
/// Parametric RPC call. Returned is pair [true|false, result], true, if call was successfull, false otherwise
/// result contains the optional return value of rpcCallResultHandle
  function rpcCall(rpcId, rpcArgs)
  var rpcResult, result = [];
  {
    // 1) check if m_ioMaster is not null and active
    rpcMasterAssert(m_ioMaster);
    // assert RPC id
    rpcCapsAssert(rpcId);
    // 2) create try-catch scope
    try
    {
      // 3) lock m_ioMaster
      m_ioMaster.lock();
      // assign io address
      m_ioMaster$clientAddr = m_ioAddr;
      // call io attempt handler
      onIoAttempt();
      // 4) perform rpc call
      if( EsRpcStdId$$CAPS_GET == rpcId )
      {
        rpcResult = m_ioMaster.getImplementedRPCs();
        m_caps = rpcResult;
      }
      else
        rpcResult = internalCallMaster(rpcId, rpcArgs);
      // call io success handler
      onIoSuccess();
      // 5) handle its result - call result handler, if registered for rpcId
      rpcResult = rpcCallResultHandle(rpcId, rpcArgs, rpcResult);
      // restore broadcast address
      m_ioMaster$clientAddr = 255;
      // 7) unlock m_ioMaster
      m_ioMaster.unlock();
      result += true; result#append(rpcResult);
    }
    catch
    {
      // 6) handle error
      onIoError(__exception$reason);
      // restore broadcast address
      m_ioMaster$clientAddr = 255;
      // 7) unlock m_ioMaster
      m_ioMaster.unlock();
      result += false; result += __exception$reason;
    }

    return result;
  }
  
/// Batch item checking
  function batchItemAssert(batchItem)
  {
    if( batchItem#isEmpty() )
      throw "Device io batch item must not be empty";

    if( !batchItem#isIndexed() )
      throw "Device io batch item must be of indexed type";
    
    if( 2 != batchItem.countGet() )
      throw "Wrong device io batch item member count.";
  }
  
/// Batch io call service. It's expecting collection of input arrays: [rpcId, args]
/// as 'batch' argument. Returned is the collection of pairs [true|false, stepResult] 
/// The first pair member is true, if no errors occurred during batch execution.
/// Otherwise, the first pair member is false.
  function rpcBatchCall(batch)
  var batchResult = [], stepResult, rpcResult, batchItem, rpcId, rpcArgs;
  {
    // 1) check if m_ioMaster is not null and active
    rpcMasterAssert(m_ioMaster);
    // 2) create try-catch scope
    try
    {
      // 3) lock m_ioMaster
      m_ioMaster.lock();
      // assign io address
      m_ioMaster$clientAddr = m_ioAddr;
      // iterate batch
      foreach(batchItem in batch)
      {
        // assert batch item structure
        batchItemAssert(batchItem);
        // call io attempt handler
        onIoAttempt();
        // 4) perform rpc call
        rpcId = batchItem[0];
        // assert RPC id
        rpcCapsAssert(rpcId);
        rpcArgs = batchItem[1];
        if( EsRpcStdId$$CAPS_GET == rpcId )
        {
          rpcResult = m_ioMaster.getImplementedRPCs();
          m_caps = rpcResult;
        }  
        else
          rpcResult = internalCallMaster(rpcId, rpcArgs);
        // call io success handler
        onIoSuccess();
        // 5) handle its result - call result handler, if registered for rpcId
        rpcResult = rpcCallResultHandle(rpcId, rpcArgs, rpcResult);
   
        stepResult = [];
        stepResult += true; stepResult#append(rpcResult);
        batchResult#append(stepResult);
      }
      // restore broadcast address
      m_ioMaster$clientAddr = 255;
      // 7) unlock m_ioMaster
      m_ioMaster.unlock();
    }
    catch
    {
      // 6) handle error
      onIoError(__exception$reason);
      // restore broadcast address
      m_ioMaster$clientAddr = 255;
      // 7) unlock m_ioMaster
      m_ioMaster.unlock();
      // create result pair
      stepResult = [];
      stepResult += false; stepResult += __exception$reason;
      batchResult#append(stepResult);
    }
    
    return batchResult;
  }
  
/// Handle -to device event. Default implementation handles
/// single, batch, and custom requests
  function evtDestAssert(devIdStr)
  {
    if( "all" != devIdStr && m_tmpFwIdStr != devIdStr )
      throw "Event mistakenly dispatched to the wrong device";
  }

  function evtHandle(evtId, evtPayload)
  var result, request, devIdStr = evtPayload[0];
  {
    evtDestAssert(devIdStr);
    
    if( EsDeviceEvtId$$rpcRequest == evtId )
    {
      request = evtPayload[1];
      result = rpcCall(request[0], request[1]);
      evtResponsePost(EsDeviceEvtId$$rpcResponse, request, result);
    }
    else if( EsDeviceEvtId$$rpcRequestBatch == evtId )
    {
      request = evtPayload[1];
      result = rpcBatchCall(request);
      evtResponsePost(EsDeviceEvtId$$rpcResponseBatch, request, result);
    }
    else if( EsDeviceEvtId$$customRequest == evtId )
    {
      request = evtPayload[1];
      result = callMethod(request[0], request[1]);
      evtResponsePost(EsDeviceEvtId$$customResponse, request, result);
    }
  }
  
/// Custom request handlers to simplify RPC FS operations
///
/// Internal fsresult substitution helper. Must not be used directly
  function checkFsResultOnSuccess( result, fsItemName )
  {
    if( result[0] && EsFsResult$$OK != result[1] )
    {
      result[0] = false;
      result[1] = fsResultStringGet(result[1]);
			if( !fsItemName#isEmpty() )
				result[1] += ": '" + fsItemName + "'";
    }
    
    return result;
  }
  
/// Start listing objects in specified 'pathAbs' (must be absolute path) directory
  function dirListStart(dirAbsPath)
  var result, bs = EsStr::toByteString(dirAbsPath);
  {
    // send zero-terminated buffer, including terminating 0
    bs += B'\0';
    result = rpcCall(EsRpcStdId$$DIR_LIST_START, bs);
    result = checkFsResultOnSuccess( result, dirAbsPath );
    
    return result;
  }

/// Proceed with directory listing, started by 'dirListStart' call
/// If directory contains no more entries, the call returns [true, null]
/// Otherwise, [true, <current EsFsItem>] is returned
  function dirListGetNextItem()
  var fsResult, result = rpcCall(EsRpcStdId$$DIR_LIST_NEXT_GET, null);
  {
    if( result[0] )
    {
      fsResult = result[1];
      if( !fsResult#isObject() )
      {
        if( EsFsResult$$OK != fsResult )
        {
          result[0] = false;
          result[1] = fsResultStringGet(fsResult);
        }
        else
          result[1] = null;
      }
      else
      {
        // return 'prepared' EsFsItem object, instead of 'compound' EsFsItemResult
        result[1] = new EsFsItem();
        result[1].copyFrom(fsResult.f_item);
      }
    }
     
    return result;
  }

/// Directory deletion service. If 'force' is true, tries to delete all directory content, if any.
/// Otherwise, aborts deletion if directory is not empty.
  function dirDelete(dirAbsPath, force)
  var bs = EsStr::toByteString(dirAbsPath), args = [], result;
  {
    // send zero-terminated buffer, including terminating 0
    bs += B'\0';  
    args += bs;
    args += force;
    result = rpcCall(EsRpcStdId$$DIR_DELETE, args);
    result = checkFsResultOnSuccess( result, dirAbsPath );
    
    return result;
  }
  
/// File deletion service.
  function fileDelete(fileAbsPath)
  var bs = EsStr::toByteString(fileAbsPath), result;
  {
    // send zero-terminated buffer, including terminating 0
    bs += B'\0';
    result = rpcCall(EsRpcStdId$$FILE_DELETE, bs);
    result = checkFsResultOnSuccess( result, fileAbsPath );
    
    return result;
  }

/// Free filesystem information query service.
  function fileSysFreeSpaceInfoGet()
  var result = rpcCall(EsRpcStdId$$FS_FREESPACE_GET, null), infoResult;
  {
    if( result[0] )
    {
      infoResult = result[1];
      if( EsFsResult$$OK != infoResult.f_result )
      {
        result[0] = false;
        result[1] = fsResultStringGet(infoResult.f_result);
      }
      else
      {
        // return 'prepared' EsFsSpaceInfo object instead of 'compound' EsFsSpaceInfoResult
        result[1] = new EsFsSpaceInfo();
        result[1].copyFrom(infoResult.f_info);
      }
    }
      
    return result;
  }

  /// File read service. May perform multiple calls to the low-level RPC
  /// file read services. Return entire file as binary buffer.
  function fileRead(fileAbsPath)
  var bs = EsStr::toByteString(fileAbsPath), fsResult, 
      f = EsVar::as(EsVariantType$$VAR_BIN_BUFFER), 
      chunks, chunk, result;
  {
    // send zero-terminated buffer, including terminating 0
    bs += B'\0';
    result = rpcCall(EsRpcStdId$$FILE_READ_START, bs);
    if( result[0] )
    {
      // todo: notify file read start action
      fsResult = result[1];
      if( EsFsResult$$OK != fsResult.f_result )
      {
        result[0] = false;
        result[1] = fsResultStringGet(fsResult.f_result);
        if( !fileAbsPath#isEmpty() )
					result[1] += ": '" + fileAbsPath + "'";
        // todo: notify action end with error
      }
      else
      {
        chunks = fsResult.f_chunks;
        chunk = 0;
        // todo: re-notify file read start action with known range now
        while( result[0] && chunk < chunks )
        {
          result = rpcCall(EsRpcStdId$$FILE_READ_NEXT, null);
          if( result[0] )
          {
            f += result[1];
            // todo: notify action progress
          }
          ++chunk;
        }
        
        if( result[0] )
        {
          // todo: notify file read action end OK
          result[1] = f;
        }
        else
        {
          // todo: notify file read action end with error
          result[1] = null;
        }
      }
    }
    
    return result;
  }
  
/// Properties:
///   
/// Currently used io master. Must be set to null when device goes inactive.
/// Must be re-assigned (by branch, or whatever) when device goes active
  property ioMaster;
  write: { m_ioMaster = __value; }

/// Read-only access to the device fwid string
  property fwIdStr;
  read: { return m_tmpFwIdStr; }
  
/// Read-only access to the device fwid
  property fwId;
  read: var tmp = new EsFirmwareId(); { 
    tmp.copyFrom(m_fwId);
    return tmp;
  }
  
/// Read-only access to actual (downloaded from physical device itself) capabilities
  property caps;
  read: { return m_caps; }
  
/// Return last successful IO timestamp
  property ioSuccessTs;
  read: { return m_ioSuccessTs; }
  
/// Return last IO attempt timestamp
  property ioAttemptTs;
  read: { return m_ioAttemptTs; }
  
/// Return current count of IO attempt errors
  property ioErrorCount;
  read: { return m_ioErrorCount.asULong(); }
  
/// Return currently set io address
  property ioAddr;
  read: { return m_ioAddr.asULong(); }
  
/// Return error log collection, if any
  property ioErrorLog;
  read: { return m_ioErrorLog; }
  
/// Payload access
  property payload;
  read: { return m_payload; }
  write: { 
    m_payload = __value;
    evtPost("fromDevice", EsDeviceEvtId$$payloadChanged, "payload");
  }
}

/// Return true if batch results are all OK,
/// false otherwise
function deviceCheckBatchResultOk(batchResult)
var batchItem;
{
  if( batchResult#isEmpty() || !batchResult#countGet() )
    return false;
  
  foreach( batchItem in batchResult )
    if( !batchItem[0] )
      return false;
      
  return true;
}

/// Try to read and return device firmware id object
function deviceFwIdRead(rpcMaster)
var fwId, rpcResult = rpcMaster.BYTEARRAY_Call(EsRpcStdId$$FWID_GET);
{
  if( !rpcResult#isEmpty() )
  {
    fwId = new EsFirmwareId();
    fwId$buffer = rpcResult#asBinBuffer();
  }
  
  return fwId;
}
