// el3c-calibration script
##require("EsDeviceBase.ess");
##require("el3c.ess");
##require("el3c/calibration/Consts.ess");
##require("el3c/calibration/Helpers.ess");
##require("el3c/calibration/ProfileClear.ess");
##require("el3c/calibration/ProfileColor.ess");

/// Calibration|verification session object
object EL3C_CalibrationSession
{
  var 
  // Session creation timestamp 
    m_created,
  // Current session mode: verification|calibration|complete. Set to complete on session completion.
    m_mode, 
  // Completed variable holds completion timestamp, set automatically on session completion.
    m_complete,
  // Settings backup snapshot, taken upon session creation  
    m_bak,
  // Current settings state  
    m_cur,
  // Clear calibration profile used in session
    m_profileClear,
  // Color calibration profile used in session
    m_profileColor; 
  
  // Parametrized constructor
  new(mode, settingsBak, profileClear)
  var type;
  {
    m_created = EsDateTime::now();
    m_mode = mode;
    m_bak = settingsBak;
    m_cur = settingsBak.clone();
    m_profileClear = profileClear.clone();
    m_profileClear$linkedSettings = m_cur;
    // TODO:m_profileColor = 
  }
  
  /// Clear calibration simulation. Calculate pair of calibrated values [clear, color],
  /// taking raw data struct as input, and using dataType to specify which calibration spline
  /// to use, and how to interpret input values
  ///
  function calibrationSimulationGet(rawData, type)
  var splineClear, splineColor, result = [null, null], 
      raw, simulated;
  {
    // Clear calibration simulation
    el3cClearCalibrationTypeCheck(type);
    raw = [null, null];
    simulated = [null, null];
    if( EL3C_CalibrationType$$Illuminance == type )
    {
      splineClear = m_cur$calClear$calIlluminance;
      splineColor = m_cur$calColor$calIlluminance;
    }
    else if( EL3C_CalibrationType$$Luminance == type )
    {
      splineClear = m_cur$calClear$calLuminance;
      splineColor = m_cur$calColor$calLuminance;
    }
    else if( EL3C_CalibrationType$$Pulsation == type )
      splineClear = m_cur$calClear$calPulsation;
    
    if( !splineClear#isEmpty() && splineClear$valid )
    {
      if( EL3C_CalibrationType$$Pulsation == type )
        raw[0] = rawData$kpi;
      else
        raw[0] = rawData$val;
      
      simulated[0] = splineClear.calculate( raw[0] );
        
      if( simulated[0] < 0 )
        simulated[0] = 0;
    }

    if( !splineColor#isEmpty() && splineColor$valid )
    {
      raw[1] = rawData$white;
      simulated[1] = splineColor.calculate( raw[1] );
      
      if( simulated[1] < 0 )
        simulated[1] = 0;
    }
    
    result[0] = raw;
    result[1] = simulated;
    
    // TODO: color XYZ|CCT simulation
    
    return result;
  }
  
  /// Restore calibration from bak storage
  function settingsRestore(device)
  var response = device.settingsUpload(m_bak);  
  {
    if( deviceCheckBatchResultOk(response) )
      m_cur.copyFrom(m_bak);
      
    return response;
  }
  
  /// Set calibration from cur storage
  function settingsSet(device)
  var response = device.settingsUpload(m_cur);  
  {
    return deviceCheckBatchResultOk(response);    
  }
  
  /// Load settings from other session file and set it to device
  function settingsSetFromOther(device, otherPath)
  var response, other = __scriptHost$script.exec("sessionOpen", otherPath), otherSettings;
  {
    if( !other$isComplete )
      throw EsStr::format("Could not copy settings from incomplete session '%s'", otherPath);
    
    otherSettings = other$settingsCur.clone();
    otherSettings.f_fwId.copyFrom( m_bak.f_fwId );
    otherSettings.f_swInfo.copyFrom( m_bak.f_swInfo );
  
    response = device.settingsUpload( otherSettings );  
    if( deviceCheckBatchResultOk(response) )
    {
      m_cur.copyFrom( otherSettings );
      return true;
    }
    
    return false;
  }
  
  /// Custom stream writer
  function streamWrite(stream)
  {
    m_bak.crcUpdate();
    m_cur.crcUpdate();  
    stream.valueWrite("created", m_created);
    stream.valueWrite("mode", m_mode);
    stream.valueWrite("completed", m_complete);
    stream.valueWrite("bak", m_bak);
    stream.valueWrite("cur", m_cur);
    stream.valueWrite("profileClear", m_profileClear);
    stream.valueWrite("profileColor", m_profileColor);
  }
  
  /// Custom stream reader
  function streamRead(stream)
  {
    m_created = stream.valueRead("created", EsDateTime::now());
    m_mode = stream.valueRead("mode", PHAC01_SessionMode$$Verification);
    m_complete = stream.valueRead("completed", null);
    m_bak = stream.valueRead("bak", null);
    m_cur = stream.valueRead("cur", null);
    m_profileClear = stream.valueRead("profileClear", null);
    m_profileClear$linkedSettings = m_cur;
    m_profileColor = stream.valueRead("profileColor", null);
  } 
  
  /// Properties
  ///  
  
  /// Sessions creation time
  property created;
  read: { return m_created; }
  
  /// Is Session comlpete
  property isComplete;
  read: { return !m_complete#isEmpty() &&
          PHAC01_SessionMode$$Complete == m_mode; }
  
  /// Session working mode
  property mode;
  read: { return m_mode; }
  write: { 
    if( !(__value in PHAC01_SessionMode) )
      throw "Invalid working mode value";
    m_mode = __value; }
  
  /// Session completion timestamp
  property completed;
  read: { return m_complete; }

  /// Completion string representation
  property completedStr;
  read: { 
    if( m_complete#isEmpty() )
      return "Not complete";
    else
      return m_complete.asString(); 
  }
  
  /// Firmware ID
  property fwId;
  read: { return m_bak.f_fwId; }

  /// Firmware ID string
  property fwIdStr;
  read: { return m_bak.f_fwId$fwIdString; }
  
  /// Get clear calibration profile
  property profileClear;
  read: { return m_profileClear; }
  
  /// Get color calibration profile
  property profileColor;
  read: { return m_profileColor; }
  
  /// Get session imformation string
  property sessionInfoStr;
  read: { 
    return EsStr::format("Session: %s, Created: %s, Complete: %s", 
      $fwIdStr, 
      m_created.asString(), 
      $completedStr 
    ); 
  }
  
  /// Get settings currently being changed/applied
  property settingsCur;
  read: { return m_cur; }
}

/// Calibration sessions file manipulation
///
function sessionPathGet(pathActive, idStr)
var spath = EsPath::createFromPath(pathActive);
{
  spath$fileName = EsPath::makeSafe(idStr, ". ;-", "_");
  spath$fileExt = "session";
  
  return spath;
}

function activeSessionSave(pathActive, session)
var idStr = session$fwIdStr, spath = sessionPathGet(pathActive, idStr);
var stream = new EsStreamXml(EsStreamFlag$$Write|EsStreamFlag$$File, spath.pathGet(EsPathFlag$$Default, ""));
{
  stream.objectWrite(session);
  stream.save(spath.pathGet(EsPathFlag$$Default, ""));
}

function sessionOpen(path)
var stream, session;
{
  if( EsPath::fileExists(path, "") )
  {
    session = new EL3C_CalibrationSession();
    stream = new EsStreamXml(EsStreamFlag$$Read|EsStreamFlag$$File, path);
    if( stream.firstRootObjectLocate() )
      stream.objectRead(session);
  }
  
  return session;
}

function activeSessionLoadOrCreate(pathActive, device, profile, newMode)
var response, idStr = device$fwIdStr, stream, session;
var spath = sessionPathGet(pathActive, idStr);
{
//  EsScriptDebug::log("spath=%s", spath.pathGet(EsPathFlag$$Default, ""));
//  EsScriptDebug::log("spath exists? %s", spath.exists("") ? "yes" : "no");

  // try to find existing active session file first
  if( spath.exists("") )
  {
    session = new EL3C_CalibrationSession();
    stream = new EsStreamXml(EsStreamFlag$$Read|EsStreamFlag$$File, spath.pathGet(EsPathFlag$$Default, ""));
    if( stream.firstRootObjectLocate() )
    {
      stream.objectRead(session);
      if( session.m_bak.f_fwId != device$fwId )
        throw EsStr::format("Settings id '%s' incompatible with device '%s'",
          session.m_bak.f_fwId$fwIdString, idStr);
      
      return session;
    }
  }
  
  // create new session in specific mode newMode
  // read current settings from device, and save them in session
  response = device.settingsDownload();
  if( response[0] )
  {
    session = new EL3C_CalibrationSession(newMode, response[1], profile);
    activeSessionSave(pathActive, session);
  }
  
  return session;
}

function activeSessionComplete(pathActive, pathComplete, session)
var spath, scpath, idStr = session$fwIdStr, stream;
{
  if( !session$isComplete )
  {
    session.m_complete = EsDateTime::now();
    session.m_mode = PHAC01_SessionMode$$Complete;
    
    spath = sessionPathGet(pathActive, idStr);
    scpath = sessionPathGet(pathComplete, idStr + " " + session.m_complete.asString());
    
    stream = new EsStreamXml(EsStreamFlag$$Write|EsStreamFlag$$File, "");
    // save to complete sessions folder
    stream.objectWrite(session);
    stream.save(scpath.pathGet(EsPathFlag$$Default, ""));
    // find and remove active session file
    if( spath.fileExists("") )
      EsPath::fileRemove(spath.pathGet(EsPathFlag$$Default, ""));
  }
}

// session file enumeration helper object
object SessionsEnumerator
{
 var m_helper, 
     m_sessionFiles;
 
 new()
 {
  m_helper = new EsPathEnumeratorHelper(this);
  m_sessionFiles = [];
 }

 function search(path)
 {
  m_sessionFiles = [];
  m_helper.enumerate(path, "*.session", EsPathEnumeratorFlag$$Default);
 }
 
 function onObject(curPath, name, isDir)
 {
  if( !isDir )
    m_sessionFiles += curPath+name;
    
  return true;
 }
 
 property sessions;
 read: { return m_sessionFiles; }
}

function activeSessionFilesGet(pathActive)
var enumerator = new SessionsEnumerator();
{
 enumerator.search(pathActive);
 return enumerator$sessions;
}

function allSessionsComplete(pathActive, pathComplete)
var sessionFiles = activeSessionFilesGet(pathActive), 
  sessionFile, session;
{
 foreach(sessionFile in sessionFiles)
 {
  session = sessionOpen(sessionFile);
  activeSessionComplete(pathActive, pathComplete, session);
 }
}

function allSessionsDelete(pathActive)
var sessionFiles = activeSessionFilesGet(pathActive), 
  sessionFile;
{
 foreach(sessionFile in sessionFiles)
   EsPath::fileRemove(sessionFile);
}
