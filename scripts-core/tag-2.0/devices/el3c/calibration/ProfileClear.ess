/// Clear calibration profile object
///

/// Reference profile node
object EL3C_ClearProfileNode
{
  var m_ref,              // Reference value
      m_deviation,        // Allowed deviation form reference value
      m_rawAnl,           // Raw uncalibrated value of Analog sensor used to calculated spline node
      m_rawDig,           // Raw uncalibrated value of Digital sensor used to calculated spline node
      m_verified,         // Calibrated value written during verification stage
      m_system,           // System node marker - we may not delete these nodes
      m_integrationType;  // Integration type allowed for this profile node. Used for template profile nodes only. ignored otherwise.
    
  function compare(other)
  {
    if( !other#isEmpty() )
    {
      if( !other#isKindOf("EL3C_ClearProfileNode") )
        throw I"Incompatible comparison argument type, must be 'EL3C_ClearProfileNode'";
      
      if( EsUtils::areEqualFloats(m_ref, other.m_ref) )
        return 0;
      else if(m_ref < other.m_ref)
        return -1;
    }
    
    return 1;
  }
    
  function refValidate(ref)
  {
    if( ref < 0 )
      throw I"Reference must be non-negative value";
  }
  
  function deviationValidate(deviation)
  {
    EsNumericCheck::checkRangeFloat(
      0, 
      0.9, 
      deviation, 
      I"Reference deviation"
    );
  }
    
  function deviationSet(deviation)
  {
    deviationValidate(deviation);
    m_deviation = deviation#asDouble();  
  }  
    
  new(ref, deviation, integrationType)
  {
    refValidate(ref);
    m_ref = ref#asDouble();
    deviationSet(deviation);
    m_system = false;
    m_integrationType = integrationType;
  }

  /// Custom stream writer
  function streamWrite(stream)
  {
    stream.propertiesWrite( this );
    stream.valueWrite("isSystem", m_system);
  }
  
  /// Custom stream reader
  function streamRead(stream)
  {
    stream.propertiesRead( this );
    m_system = stream.valueRead("isSystem", false);
  }    
 
  /// Reference node value
  property ref;
  @persistent;
  read: { return m_ref; }
  write: { refValidate(__value); m_ref = __value#asDouble(); }
  
  /// reference formatted string
  property refStr;
  read: { return EL3C_ValueFmt( m_ref ); }    
  
  /// reference node deviation ratio, 0..0.9 (0..90%)
  property deviation;
  @persistent;
  read: { return m_deviation; }
  write: { deviationValidate(__value); m_deviation = __value#asDouble(); }
  
  /// Reference node deviation ratio, 0..0.9 (0..90%)
  property deviationStr;
  read: { return EsStr::format("%0.1f %%", m_deviation*100.); }
  
  /// Reference node calculated minimum
  property refMin;
  read: { return m_ref*(1.-m_deviation); }
  
  /// Reference node calculated minimum string
  property refMinStr;
  read: { return EL3C_ValueFmt( $refMin ); }
  
  /// Reference node calculated maximum
  property refMax;
  read: { return m_ref*(1.+m_deviation); }
  
  /// Reference node calculated maximum string
  property refMaxStr;
  read: { return EL3C_ValueFmt( $refMax ); }

  /// Raw uncalibrated analog value
  ///
  property rawAnl;
  @persistent;
  read: { return m_rawAnl; }
  write: { m_rawAnl = __value; }

  /// Backward compatibility property
  property rawOsram;
  read: { return $rawAnl; }
  write: { $rawAnl = __value; }
  
  /// Raw uncalibrated value string
  property rawAnlStr;
  read: { 
    if(m_rawAnl#isEmpty()) 
      return "";
    else 
      EL3C_ValueFmt(m_rawAnl); 
  }
  
  /// Analog - Backward compatibility
  property rawOsramStr;
  read: { return $rawAnlStr; }

  /// Raw uncalibrated digital value
  property rawDig;
  @persistent;
  read: { return m_rawDig; }
  write: { m_rawDig = __value; }
  
  /// Raw uncalibrated digital value string
  property rawDigStr;
  read: { 
    if(m_rawDig#isEmpty()) 
      return "";
    else 
      EL3C_ValueFmt(m_rawDig); 
  }
  
  /// Digital - Backward compatibility
  property rawMax4400x;
  read: { return $rawDig; }
  write: { $rawDig = __value; }
  
  property rawMax4400xStr;
  read: { return $rawDigStr; }
 
  /// Calibrated verified value
  property verified;
  @persistent;
  read: { return m_verified; }
  write: { m_verified = __value;}
  
  /// Live verified node string
  property verifiedStr;
  read: { 
    if(m_verified#isEmpty()) 
      return "";
    else 
      EL3C_ValueFmt(m_verified); 
  }
 
  /// Node was used in calibration - it has raw value set
  property hasRawAnl;
  read: { return !m_rawAnl#isEmpty(); }
  
  property hasRawDig;
  read: { return !m_rawDig#isEmpty(); }

  property hasRawValues;
  read: { return $hasRawAnl || $hasRawDig; }
  
  /// Backward compatibility
  property hasRawOsram;
  read: { return $hasRawAnl; }

  property hasRawMax4400x;
  read: { return $hasRawDig; }
  
  /// Node integration preferences
  property integrationType;
  @persistent;
  read: { 
    if( !m_integrationType#isEmpty() )
      return m_integrationType;
    
    return 3;
  }
  write: { 
    if( __value > 3 ) 
      m_integrationType = 3; //< All
    else if( __value < 1 )
      m_integrationType = 2; //< Slow only
    else
      m_integrationType = __value;
  }
  
  /// Return system flag
  property isSystem;
  read: { return m_system#asBool(); }
}

/// Reference profile.
object EL3C_ClearCalibrationProfile
{
  var m_name, // Calibration profile name
    m_lux,    // Illuminance calibration nodes
    m_cdm,    // Luminance calibration nodes
    m_kp,     // Pulsation calibration nodes
    m_linkedSettings; // Optional linked settings object, to allow automatic
                      // calibration update on node values change

  // Internal helper. Create default node collection contents
  function defaultNodesCreate(type)
  var result = [];
  {
    if( type in [EL3C_CalibrationType$$Illuminance .. EL3C_CalibrationType$$Luminance] )
    {
      // Lux and Cdm will have at least one zero system point
      result += new EL3C_ClearProfileNode(
        0, 
        0.1, 
        3     //< Integrate both
      );
      result[0].m_system = true;
    }
    else
    {
      // Pulsation will always have 2 system points - 0 and 100%
      result += new EL3C_ClearProfileNode(
        0, 
        0.1,
        3     //< Integrate both
      );
      result += new EL3C_ClearProfileNode(
        100, 
        0.1,
        1     //< Integrate fast only
      );
      result[0].m_system = true;
      result[1].m_system = true;
      // Moreover, we can pre-set raw values for system nodes as well
      result[0]$rawAnl = 0;
      result[1]$rawAnl = 100;
    }
    
    return result;
  }
  
  // Internal helper. Reset raw data for profile node of specified type
  function intenralNodeRawDataReset(node, type)
  {
    if( EL3C_CalibrationType$$Pulsation == type )
    {
      // Reset values for zero or 100% points to default
      if( EsUtils::areEqualFloats(0., node$ref) )
        node$rawAnl = 0;
      else if( EsUtils::areEqualFloats(100., node$ref) )
        node$rawAnl = 100;
    }
    else
      node$rawAnl = null;

    node$rawDig = null;
    node.m_verified = null;
  } 
   
  /// Access nodes collection of specified type
  function nodesGet(type)
  {
    el3cClearCalibrationTypeCheck(type);
    if( EL3C_CalibrationType$$Illuminance == type )
      return m_lux;
    else if( EL3C_CalibrationType$$Luminance == type )
      return m_cdm;
    else
      return m_kp;
  }   
   
  /// Get all profile nodes, which have raw data assigned
  function nodesWithRawDataGet(type)
  var nodes = nodesGet(type), node, result = [];
  {
    foreach(node in nodes)
    {
      if( node$hasRawValues )
        result += node;
    }
    
    return result;
  }
  
  /// Get all profile nodes of specific kind, which have raw data assigned
  function nodesWithRawDataGet(type, isAnl)
  var nodes = nodesGet(type), node, result = [];
  {
    foreach(node in nodes)
    {
      if( isAnl )
      {
        if( node$hasRawAnl )
          result += node;
      }
      else if( node$hasRawDig )
          result += node;
    }
    
    return result;
  }
  
  /// Calculate fitting spline nodes for specified node types, and sensor kind (anl|dig)
  /// If fitting spline could not be calculated, an empty value is returned
  ///
  function fittingSplineCalculate(type, isAnl)
  var node, nodes = nodesWithRawDataGet(type, isAnl), constraint = [],
    fit, fitc = [], pfit, x = [], y = [], coeffs;
  {
    if( nodes#countGet() >= 2 && nodes#countGet() <= 8 )
    {
      fit = new EsMathSpline();
      
      foreach(node in nodes)
      {
        x += isAnl ? node$rawAnl : node$rawDig;
        y += node$ref;
      }
      
      constraint += x[0];
      constraint += y[0];
      constraint += EsMathFitConstraintKind$$Value;
      fitc#append(constraint);
      
      pfit = new EsMathPolyFit();
      
      // Create linear fit to define additional conditions 
      // for first derivatives in nodes
      //
      pfit.buildConstrained(x, y, 1, fitc);
      coeffs = pfit$coefficients;
      
      // Build fitting with constraints
      fit.akimaBuild(x, y);
      
      if( fit$isOk )
      {
        nodes = fit$nodes;
        
        // Tune up the last spline node - add linear segment
        node = [];
        node += nodes[nodes#countGet()-1][1]; // The end of the last spline segment is the start of linear segment
        node += 0;                            // Use some dummy value as the linear segment ending, it's not used anyway
        node += y[y#countGet()-1];            // Use the last reference value, as line segment starting point
        node += coeffs[1];                    // Use the line segment inclination
        node += 0;                            // Do not use any coeffs for members with power > 1
        node += 0;
        nodes#append(node);
                
        return nodes;
      }
    }
  } 
    
  // Update linked splines of specific type
  function splinesUpdate(type)
  var nodesAnl, splineAnl, nodesDig, splineDig;
  {
    if( !m_linkedSettings#isEmpty() )
    {
      if( type != EL3C_CalibrationType$$Pulsation )
      {
        nodesAnl = fittingSplineCalculate(type, true);
        nodesDig = fittingSplineCalculate(type, false);
        
        if( type == EL3C_CalibrationType$$Illuminance )
        {
          splineAnl = m_linkedSettings$calClear$calIlluminance;
          splineDig = m_linkedSettings$calColor$calIlluminance;
        }
        else
        {
          splineAnl = m_linkedSettings$calClear$calLuminance;
          splineDig = m_linkedSettings$calColor$calLuminance;
        }
      }
      else
      {
        nodesAnl = fittingSplineCalculate(type, true);
        splineAnl = m_linkedSettings$calClear$calPulsation;
      }
      
      //EsScriptDebug::log(nodesAnl);
      splineAnl.fromMathNodes(nodesAnl);
      if( !splineDig#isEmpty() )
      {
        //EsScriptDebug::log(nodesDig);
        splineDig.fromMathNodes(nodesDig);
      }
    }
  }
  
  function splinesUpdateAll()
  { 
    splinesUpdate(EL3C_CalibrationType$$Illuminance);    
    splinesUpdate(EL3C_CalibrationType$$Luminance);    
    splinesUpdate(EL3C_CalibrationType$$Pulsation);  
  }
   
  /// Clear profile nodes of specified type. Contents of collection
  /// of specified type is reset to defaults.
  ///
  function nodesClear(type)
  {
    el3cClearCalibrationTypeCheck(type);
    if( EL3C_CalibrationType$$Illuminance == type )
      m_lux = defaultNodesCreate(type);
    else if( EL3C_CalibrationType$$Luminance == type )
      m_cdm = defaultNodesCreate(type);
    else
      m_kp = defaultNodesCreate(type);
      
    splinesUpdate(type);      
  }
  
  /// Clear all node collections to defaults
  function nodesClearAll()
  {
    m_lux = defaultNodesCreate(EL3C_CalibrationType$$Illuminance);
    m_cdm = defaultNodesCreate(EL3C_CalibrationType$$Luminance);
    m_kp = defaultNodesCreate(EL3C_CalibrationType$$Pulsation);
    
    splinesUpdateAll();  
  }
  
  /// Create new profile, all node collections got created with
  /// default contents, optional profile name is set as specified
  ///
  new(name)
  {
    m_name = name#asString();
    nodesClearAll();
  }
  
  /// Return count of nodes of specified type in profile
  function nodesCountGet(type)
  {
    el3cClearCalibrationTypeCheck(type);
    if( EL3C_CalibrationType$$Illuminance == type )
      return m_lux#countGet();
    else if( EL3C_CalibrationType$$Luminance == type )
      return m_cdm#countGet();
    else
      return m_kp#countGet();
  }
  
  /// Reset raw data for profile nodes of specified type
  function nodesRawDataReset(type)
  var idx, node, nodes = nodesGet(type);
  {
    for(idx = 0; idx < nodes#countGet(); ++idx)
      intenralNodeRawDataReset(nodes[idx], type);
      
    splinesUpdate(type);      
  }
  
  /// Reset raw data for profile node of specified type
  function nodeRawDataReset(type, idx)
  var nodes = nodesGet(type);
  {
    intenralNodeRawDataReset(
      nodes[idx], 
      type
    );
    
    splinesUpdate(type);    
  }  
  
  /// Get profile node of specific type at specified index
  function nodeGet(type, idx)
  {
    return nodesGet(type)[idx];
  }
  
  /// Add node to profile
  function nodeAdd(type, ref, deviation, integrationType)
  var newNode;
  {
    newNode = new EL3C_ClearProfileNode(
      ref, 
      deviation, 
      integrationType
    );

    el3cClearCalibrationTypeCheck(type);
    if( EL3C_CalibrationType$$Illuminance == type )
    {
      m_lux#appendUnique(newNode);
      m_lux#sortAscending();
    }
    else if( EL3C_CalibrationType$$Luminance == type )
    {
      m_cdm#appendUnique(newNode);
      m_cdm#sortAscending();
    }
    else
    {
      m_kp#appendUnique(newNode);
      m_kp#sortAscending();
    }
    
    return newNode;
  }
  
  function isSystemNode(type, idx)
  var nodes = nodesGet(type);
  {
    return nodes[idx]$isSystem;
  }
  
  function nodeDelete(type, idx)
  {
    // Check if node is a system one
    if( isSystemNode(type, idx) )
      throw I"You may not delete a system node";
      
    // Finally, we are clear to do deletion
    if( EL3C_CalibrationType$$Illuminance == type )
      m_lux#itemDelete(idx);
    else if( EL3C_CalibrationType$$Luminance == type )
      m_cdm#itemDelete(idx);
    else
      m_kp#itemDelete(idx);
      
    splinesUpdate(type);      
  }
  
  function nodeSet(type, idx, ref, deviation, integrationType)
  var nodes;
  {
    if( isSystemNode(type, idx) )
    {
      nodes = nodesGet(type);
      
      // For system nodes, allow to change deviation only
      if( EsUtils::areEqualFloats(nodes[idx]$ref, ref) )
        nodes[idx].deviationSet(deviation);
      else
        throw I"Reference value of system node may not be changed";
    }  
    else
    {
      nodeDelete(
        type, 
        idx
      );
      
      nodeAdd(
        type, 
        ref, 
        deviation, 
        integrationType
      );
    }
  }
 
  function nodeRawValueSet(type, idx, rawVals)
  var node = nodeGet(type, idx), nodes = nodesWithRawDataGet(type);
  {
    // We must not change zero point for Pulsation
    if( 0 == idx && EL3C_CalibrationType$$Pulsation == type )
      throw I"Zero node for Pulsation calibration must not be changed";
    
    node$rawAnl = rawVals[0];
    if( EL3C_CalibrationType$$Pulsation != type )
      node$rawDig = rawVals[1];
        
    // If we're setting raw values for default zero node in either Illuminance
    // or Luminance, we may automatically set thte same values for other type
    if( 0 == idx ) // system zero point
    {
      if( type in [EL3C_CalibrationType$$Illuminance .. EL3C_CalibrationType$$Luminance] )
      {
        if( EL3C_CalibrationType$$Illuminance == type )
          node = nodeGet(EL3C_CalibrationType$$Luminance, 0);
        else if( EL3C_CalibrationType$$Luminance == type )
          node = nodeGet(EL3C_CalibrationType$$Illuminance, 0);
       
        node$rawAnl = rawVals[0];
        node$rawDig = rawVals[1];
      }
    }
      
    splinesUpdate(type);
  }
  
  /// Custom stream writer
  function streamWrite(stream)
  {    
    stream.valueWrite(
      "name", 
      m_name
    );
    
    stream.valueWrite(
      "lux", 
      m_lux
    );
    
    stream.valueWrite(
      "cdm", 
      m_cdm
    );
    
    stream.valueWrite(
      "kp", 
      m_kp
    );
  }
  
/// Custom stream reader
  function streamRead(stream)
  {
    m_name = stream.valueRead(
      "name", 
      "Profile"
    );
    
    m_lux = stream.valueRead(
      "lux", 
      defaultNodesCreate(EL3C_CalibrationType$$Illuminance)
    );
    
    m_cdm = stream.valueRead(
      "cdm", 
      defaultNodesCreate(EL3C_CalibrationType$$Luminance)
    );
    
    m_kp = stream.valueRead(
      "kp", 
      defaultNodesCreate(EL3C_CalibrationType$$Pulsation)
    );
  }

/// Properties
///
  property name;
  read: { return m_name; }
  write: { m_name = __value#asString(); }
  
  property isOk;
  read: 
  { 
    return  0 < m_lux#countGet() && 
            0 < m_cdm#countGet() && 
            0 < m_kp#countGet(); 
  }
  
  property linkedSettings;
  read: { return m_linkedSettings; }
  write: { m_linkedSettings = __value; splinesUpdateAll(); }
}

/// Create default profile object, with system-only points
///
function profileClearDefaultCreate()
var profile = new EL3C_ClearCalibrationProfile("DefaultProfile");
{
  return profile;
}

/// Profile files manipulation
///
function profileClearLoad(path)
var stream = new EsStreamXml(EsStreamFlag$$Read|EsStreamFlag$$File, path);
var profile;
{
  if( stream.firstRootObjectLocate() )
  {
    profile = profileClearDefaultCreate();
    stream.objectRead(profile);
  }

  return profile;
}

function profileClearSave(profile, path)
var stream = new EsStreamXml(EsStreamFlag$$Write|EsStreamFlag$$File, "");
{
  if( !profile#isKindOf("EL3C_ClearCalibrationProfile") )
    throw "Could not write incompatible object as profile";

  if( !profile$isOk )
    throw EsStr::format(
      "Could not write incomplete profile '%s'. Valid profile should contain at least one node for each data type",
      profile$name
    );
    
  stream.objectWrite(profile);  
  stream.save(path);
}
