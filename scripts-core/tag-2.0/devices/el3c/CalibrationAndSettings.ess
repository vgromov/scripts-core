/// EL3C Calibration and settings data blocks
///
##require("calibration/Consts.ess");

function el3cClearCalibrationTypeCheck(type)
{
  if( !(type in [EL3C_CalibrationType$$Illuminance .. EL3C_CalibrationType$$Pulsation]) )
    throw "Clear calibration type is out of bounds";
}

/// Clear calibration data
object EL3C_CalibrationClear
{
  EsSpline f_csIllum;    ///< Clear illumination calibration
  EsSpline f_csLum;      ///< Clear luminance calibration
  EsSpline f_csKp;       ///< Clear pulsation calibration  
  
  // We should have separate initialization 
  // method to work-around cases, when this object is used as filed
  // in other compound object(s), and default ctors are not being called for fields
  // 
  function init()
  {
    f_csIllum$maxLen = 8;
    f_csLum$maxLen = 8;
    f_csKp$maxLen = 8;
  }
  
  /// Default constructor
  new()
  {
		init();
  }  
  
  /// Update all crc blocks if needed
  function crcUpdate()
  {
    f_csIllum.crcUpdate();
    f_csLum.crcUpdate();
    f_csKp.crcUpdate();
  }
  
  /// Properties
  ///
  
  /// Return true if all blocks have valid crc
  property crcIsOk;
  read: { return f_csIllum$crcIsOk && f_csLum$crcIsOk && f_csKp$crcIsOk; }
  
  /// Overall validity check
  property valid;
  read: { return f_csIllum$valid && f_csLum$valid && f_csKp$valid; }
  
  /// Illuminance calibration access
  property calIlluminance;
  read: { return f_csIllum; }
  
  /// Luminance calibration access
  property calLuminance;
  read: { return f_csLum; }
  
  /// Pulsation calibration
  property calPulsation;
  read: { return f_csKp; }
}

/// Color calibration data
object EL3C_CalibrationColor
{
  var m_acfCrcInvalid;
  
  EL3C_CorMatrix f_ccm;     ///< XYZ color space correlation matrix
  EL3C_CorMatrix f_tcm;     ///< Color temperature correlation matrix
  EsSpline f_ccIllum;         ///< Clear channel illumination calibration
  EsSpline f_ccLum;           ///< Clear channel luminosity calibration
  esF f_acf[3];               ///< Color sensor attenuation correction factors for attenuation coefficients > 1
  esU8 f_acfCrc;              ///< ACF vector crc8 field
  
  // We should have separate initialization 
  // method to work-around cases, when this object is used as filed
  // in other compound object(s), and default ctors are not being called for fields
  // 
  function init()
  {
    m_acfCrcInvalid = true;
    f_ccIllum$maxLen = 8;
    f_ccLum$maxLen = 8;
  }  
  
  /// Default constructor
  new()
  {
    init();
  }
  
  /// Calculate CRC8 of ACF block
  function acfCrcCalc()
  var crc = new EsCRC8(f_acf#asBinBuffer(), 0xAB);
  {
    return crc;
  }
  
  /// Update ACF block crc if neccessary
  function acfCrcUpdate()
  {
    if( m_acfCrcInvalid )
    {
      f_acfCrc = acfCrcCalc()$value;
      m_acfCrcInvalid = false;
    }
  }
  
  /// Check if CRC of ACF block is OK
  function acfCrcIsOk()
  var crc;
  {
    acfCrcUpdate();
    crc = new EsCRC8(f_acfCrc#asBinBuffer(), f_acfCrc$value);
    return 0 == crc$value;
  }
  
  /// Update CRC of all blocks, if needed
  function crcUpdate()
  {
    f_ccm.crcUpdate();
    f_tcm.crcUpdate();
    f_ccIllum.crcUpdate();
    f_ccLum.crcUpdate();
    acfCrcUpdate();    
  }
  
  /// ACF block item get
  function acfGet(idx)
  {
    return f_acf[idx]$value;
  }
  
  /// ACF block item set
  function acfSet(idx, val)
  {
    f_acf[idx] = val$value;
    m_acfCrcInvalid = true;
  }
 
  /// Properties
  ///
  
  /// Return true if all blocks have valid crc
  property crcIsOk;
  read: 
  { 
    return acfCrcIsOk() && 
      f_ccm$crcIsOk && f_tcm$crcIsOk &&
       f_ccIllum$crcIsOk && f_ccLum$crcIsOk;
  }
  
  /// Overall validity check
  property valid;
  read: { return f_ccIllum$valid && f_ccLum$valid; }
  
  /// Access Color space Correlation matrix  
  property ccm;
  read: { return f_ccm; }
  
  /// Access Color temperature Correlation matrix  
  property tcm;
  read: { return f_tcm; }
  
  /// Illuminance calibration access
  property calIlluminance;
  read: { return f_ccIllum; }
  
  /// Luminance calibration access
  property calLuminance;
  read: { return f_ccLum; }
}

/// EL3C device settings
object EL3C_Settings
{
  // settings block
  EsFirmwareId f_fwId;
  EsSoftwareInfo f_swInfo;
  
  esU16 f_autosaveInterval;
    @default = EL3C_Defs$$AutoIntervalDef;
    @restriction = [EL3C_Defs$$AutoIntervalMin..EL3C_Defs$$AutoIntervalMax];
  
  esU16 f_bgndExp;
    @default = EL3C_Defs$$BgndExposureDef;
    @restriction = [EL3C_Defs$$BgndExposureMin..EL3C_Defs$$BgndExposureMax];
  
  // Clear calibration data
  EL3C_CalibrationClear f_calClear;    
  
  // Color calibration data
  EL3C_CalibrationColor f_calColor;    
  
  /// Constructors
  new()
  {
    f_fwId.copyFrom( new EsFirmwareId(EsDeviceType$$PHAC1) );
    f_calClear.init();
    f_calColor.init();
  }
  
  new(fwId)
  {
    fwIdValidate(fwId, EsDeviceType$$PHAC1, "EL3C settings");
    f_fwId.copyFrom(fwId);
    f_calClear.init();
    f_calColor.init();
  }
  
  // Return clear clibration spline by data type
  function calClearGet(type)
  {
    el3cClearCalibrationTypeCheck(type);
    if( EL3C_CalibrationType$$Illuminance == type )
      return f_calClear$calIlluminance;
    else if( EL3C_CalibrationType$$Luminance == type )  
      return f_calClear$calLuminance;
    else if( EL3C_CalibrationType$$Pulsation == type ) 
      return f_calClear$calPulsation;
  }

  // Return clear calibration splines for color sensor
  function calColorClearGet(type)
  {
    el3cClearCalibrationTypeCheck(type);
    if( EL3C_CalibrationType$$Illuminance == type )
      return f_calColor$calIlluminance;
    else if( EL3C_CalibrationType$$Luminance == type )  
      return f_calColor$calLuminance;
  }
  
  /// Update CRC data in clear and color calibrations
  function crcUpdate()
  {
    f_calClear.crcUpdate();
    f_calColor.crcUpdate();
  }
  
  /// Propertires
  ///
  property fwId;
  read: { return f_fwId.clone(); }
  
  property swInfo;
  read: { return f_swInfo.clone(); }
  
  property autosaveInterval;
  read: { return f_autosaveInterval$value; }
  write: { f_autosaveInterval = __value; }
  
  property bgndExposure;
  read: { return f_bgndExp$value; }
  write: { f_bgndExp = __value; }
  
  property calClear;
  read: { return f_calClear; }
  
  property calColor;
  read: { return f_calColor; }
  
  property crcIsOk;
  read: { return f_calClear$crcIsOk && f_calColor$crcIsOk; }
}
