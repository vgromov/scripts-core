/// Spline structure data && methods
///
/// Spline node
object EsMathSplineNode
{
  esF f_x;
  esF f_a;  ///< pow 0
  esF f_b;  ///< pow 1
  esF f_c;  ///< pow 2
  esF f_d;  ///< pow 3
  
  /// Initializing constructor
  new(x, a, b, c, d)
  {
    f_x = x$value;
    f_a = a$value;
    f_b = b$value;
    f_c = c$value;
    f_d = d$value;
  }
  
  /// Data access
  property x;
  read: { return f_x$value; }
  write: { f_x = __value; }

  property a;
  read: { return f_a$value; }
  write: { f_a = __value; }
  
  property b;
  read: { return f_b$value; }
  write: { f_b = __value; }
  
  property c;
  read: { return f_c$value; }
  write: { f_c = __value; }
  
  property d;
  read: { return f_d$value; }
  write: { f_d = __value; }
}

/// Spline itself
object EsMathSpline
{
  var m_crcInvalid,
      m_maxLen;
  
  esU16 f_cnt;
  EsMathSplineNode f_nodes[f_cnt];
  esU8 f_crc;
	  
	/// Default constructor  
	new()
	{
    m_crcInvalid = false;
    m_maxLen = 65535;  
	}  
	  
	/// Constructor taking max length value as parameter
	new(maxLen)
	{
    m_crcInvalid = false;
    m_maxLen = maxLen$value;
	}	  
	  
	/// CRC8 calculator  
  function crcCalc()
  var crc = new EsCRC8(f_cnt#asBinBuffer(), 0xAB);
  {
    if( f_cnt$value > 0 )
      crc.update(f_nodes#asBinBuffer());
    
    return crc;
  }
  
  /// Calculate CRC8 and update f_crc field
  function crcUpdate()
  {
    if( m_crcInvalid )
    {
      f_crc = crcCalc()$value;
      m_crcInvalid = false;
    }
  }
  
  /// Return true if spline contains at least 2 nodes
  function isEmpty()
  {
    return f_cnt < 2;    
  }
  
  /// Return true if spline is valid (non empty and nodes are sorted)
  function isValid()
  var node, prevX;
  {
    if( !isEmpty() )
    {
			foreach(node in f_nodes)
			{
        if( !prevX#isEmpty() && node.f_x < prevX )
          return false;
        else
          prevX = node.f_x;
			}
			
			return true;
    }
    
    return false;
  }
  
  /// Return node at index
  function nodeGet(idx)
  var node, result;
  {
    node = f_nodes[idx];
    result = new EsMathSpline();
    result.copyFrom( node );
    
    return result;
  }
  
  /// Set new spline node data at specified index
  function nodeSet(idx, node)
  {
    if( node#isEmpty() || !node.isKindOk("EsMathSplineNode") )
      throw I"Node object is empty or of incompatible type";
    
    f_nodes[idx].copyFrom(node);
    m_crcInvalid = true;
  }
  
  /// Find corresponding spline node by argument value
  /// If spline is empty, or node is not found, empty value is returned
  /// Otherwise, result is found node object
  function nodeFind(x)
  var node, left, mid , right;
  {
	  if( !isEmpty() )
	  {
			if( x <= f_nodes[0].f_x) //< use the first node, if x is out of range left-wise
				node = f_nodes[0];
			else if(x >= f_nodes[f_cnt - 1].f_x) //< use the last node, if x is out of range right-wise
				node = f_nodes[f_cnt - 1];
			else
			{
		    // Binary search in the [ x[0], ..., x[n-2] ] last element is excluded, it should be returned by 'if' above 
		    left = 0;
		    right = f_cnt-1;
		    while( left != right-1 )
		    {
		      mid = (left+right)/2;
		      if( f_nodes[mid].f_x >= x )
		        right = mid;
		      else
		        left = mid;
		    }
		
				node = f_nodes[left];
			}
		}
		
	  return node;    
  }
  
  /// Calculate spline value for specified argument
  /// If spline is empty - null is returned
  function valGet(x)
  var node = nodeFind(x), delta;
  {
    if( !node#isEmpty() )
    {
      delta = (x - node.f_x);
      return node.f_a + (node.f_b + (node.f_c / 2. + node.f_d * delta / 6.) * delta) * delta;  
    }
  }
  
  /// Properties
  ///
  
  /// Spline node collection max length restriction
  property maxLen;
  read: { return m_maxLen; }
  write: 
  {
    if( __value in [2..65535] )
      throw EsStr::format(I"Spline maximum length %d is out of [2..65536] range", __value);
      
    m_maxLen = __value;  
    if( f_cnt > m_maxLen )
      f_cnt = m_maxLen;
  }
  
  /// Validity check
  property valid;
  read: { return isValid(); }
  
  /// Calculate and return crc8 of spline data
  property crc;
  read: 
  { 
    crcUpdate();
    return f_crc$value; 
  }
  
  /// Return true if spline crc is OK
  property crcIsOk;
  read: 
  var crc = new EsCRC8(f_crc#asBinBuffer(), f_crc$value);
  { 
    return 0 == crc$value; 
  }
  
  /// Access nodes count
  property cnt;
  read: { return f_cnt$value; }
  write: 
  { 
    if( __value > m_maxLen )
      throw EsStr::format(I"Spline length must not exceed %u", m_maxLen);
  
    f_cnt = __value;
    m_crcInvalid = true;
  }
}
