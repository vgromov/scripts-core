##require("../math.ess");

/// Spline structure data && methods
///
/// Spline node
object EsSpline
{
  esF f_x;
  esF f_a;  ///< pow 0
  esF f_b;  ///< pow 1
  esF f_c;  ///< pow 2
  esF f_d;  ///< pow 3
  
  /// Initializing constructor
  new(x, a, b, c, d)
  {
    f_x = x$value;
    f_a = a$value;
    f_b = b$value;
    f_c = c$value;
    f_d = d$value;
  }
  
  /// Data access
  property x;
  read: { return f_x$value; }
  write: { f_x = __value; }

  property a;
  read: { return f_a$value; }
  write: { f_a = __value; }
  
  property b;
  read: { return f_b$value; }
  write: { f_b = __value; }
  
  property c;
  read: { return f_c$value; }
  write: { f_c = __value; }
  
  property d;
  read: { return f_d$value; }
  write: { f_d = __value; }
}

/// Spline itself
object EsMathSpline
{
  var m_crcInvalid,
      m_maxLen;
  
  esU16 f_cnt;
  EsSpline f_nodes[f_cnt];
  esU8 f_crc;
    
  /// Default constructor  
  new()
  {
    m_crcInvalid = false;
    m_maxLen = 65535;  
  }  
    
  /// Constructor taking max length value as parameter
  new(maxLen)
  {
    m_crcInvalid = false;
    m_maxLen = maxLen$value;
  }    
    
  /// CRC8 calculator  
  function crcCalc()
  var crc = new EsCRC8(f_cnt#asBinBuffer(), 0xAB);
  {
    if( f_cnt$value > 0 )
      crc.update(f_nodes#asBinBuffer());
    
    return crc;
  }
  
  /// Calculate CRC8 and update f_crc field
  function crcUpdate()
  {
    if( m_crcInvalid )
    {
      f_crc = crcCalc()$value;
      m_crcInvalid = false;
    }
  }
  
  /// Return true if spline contains at least 2 nodes
  function isEmpty()
  {
    return f_cnt > 0;    
  }
  
  /// Return true if spline is valid (non empty and nodes are sorted)
  function isValid()
  var node, prevX;
  {
    if( !isEmpty() )
    {
      foreach(node in f_nodes)
      {
        if( !prevX#isEmpty() && node.f_x < prevX )
          return false;
        else
          prevX = node.f_x;
      }
      
      return true;
    }
    
    return false;
  }
  
  /// Check len agains maximum length restriction
  function maxLenCheck(len)
  {
    if( len > m_maxLen )
      throw EsStr::format(I"Spline length must not exceed %u", m_maxLen);
  }
  
  /// Check node object is valid, does not have the same x as an existing one
  function nodeCheck(node)
  var lnode;
  {
    if( node#isEmpty() || !node.isKindOk("EsSpline") )
      throw I"Node object is empty or of incompatible type";
      
    foreach(lnode in f_nodes)
    {
      if( EsUtils::areEqualFloats(node.f_x, lnode.f_x) )
        throw I"Node with specified x already exists within spline";
    }
  }
  
  /// Return node at index
  function nodeGet(idx)
  var node, result;
  {
    node = f_nodes[idx];
    result = new EsMathSpline();
    result.copyFrom( node );
    
    return result;
  }
  
  /// Set new spline node data at specified index
  function nodeSet(idx, node)
  {
    nodeCheck(node);
    
    f_nodes[idx].copyFrom(node);
    m_crcInvalid = true;
  }
  
  /// Append new node to the spline. New node is checked against existing ones,
  /// to maintain sorting by x value, and prevent nodex with duplicate x values.
  /// Maximum length restriction is maintained as well. 
  /// If node is added successfully, new node index is returned.
  /// Otherwise, an exception is thrown.
  ///
  function nodeAppend(node)
  var idx, left, right, mid, tmp;
  {
    nodeCheck(node);
    maxLenCheck(f_cnt+1);
    
    if( !isEmpty() )
    {
      if( node.f_x <= f_nodes[0].f_x) //< insert node before the first one
        idx = 0;
      else if(node.f_x >= f_nodes[f_cnt - 1].f_x) //< append node after the last one
        idx = f_cnt;
      else
      {
        // Find the index of last element which f_x is less, than x 
        left = 0;
        right = f_cnt-1;
        while( left != right-1 )
        {
          mid = (left+right)/2;
          if( f_nodes[mid].f_x >= node.f_x )
            right = mid;
          else
            left = mid;
        }

        idx = left+1;
      }
      
      /// Increment array count (an empty element is added to the end of array)
      f_cnt += 1;
      
      /// Move all elements, starting at idx, one position right
      f_nodes.shiftRight(idx);
        
      /// Set new node at idx
      f_nodes[idx].copyFrom( node );
    }
    else
    {
      f_cnt += 1;
      idx = 0;
      f_nodes[idx].copyFrom( node );
    }
    
    return idx;
  }
  
  /// Delete node at specified index
  function nodeDelete(idx)
  {
    if( 0 <= idx && idx < f_cnt )
    {
      if( idx < f_cnt-1 )
        f_nodes.shiftLeft(idx+1);
      f_cnt -= 1;
    }
  }
  
  /// Find corresponding spline node by argument value
  /// If spline is empty, or node is not found, empty value is returned
  /// Otherwise, result is the found node object.
  ///
  function nodeFind(x)
  var node, left, mid, right;
  {
    if( !isEmpty() )
    {
      if( x <= f_nodes[0].f_x) //< use the first node, if x is out of range left-wise
        node = f_nodes[0];
      else if(x >= f_nodes[f_cnt - 1].f_x) //< use the last node, if x is out of range right-wise
        node = f_nodes[f_cnt - 1];
      else
      {
        // Binary search in the [ x[0], ..., x[n-2] ] last element is excluded, it should be returned by 'if' above 
        left = 0;
        right = f_cnt-1;
        while( left != right-1 )
        {
          mid = (left+right)/2;
          if( f_nodes[mid].f_x >= x )
            right = mid;
          else
            left = mid;
        }
    
        node = f_nodes[left];
      }
    }
    
    return node;    
  }
  
  /// Calculate spline value for specified argument
  /// If spline is empty - null is returned
  function valGet(x)
  var node = nodeFind(x), delta;
  {
    if( !node#isEmpty() )
    {
      delta = (x - node.f_x);
      return node.f_a + (node.f_b + (node.f_c / 2. + node.f_d * delta / 6.) * delta) * delta;  
    }
  }
  
  /// Properties
  ///
  
  /// Spline node collection max length restriction
  property maxLen;
  read: { return m_maxLen; }
  write: 
  {
    if( __value in [2 .. 65535] )
      throw EsStr::format(I"Spline maximum length %d is out of [2..65536] range", __value);
      
    m_maxLen = __value;  
    if( f_cnt > m_maxLen )
      f_cnt = m_maxLen;
  }
  
  /// Validity check
  property valid;
  read: { return isValid(); }
  
  /// Calculate and return crc8 of spline data
  property crc;
  read: 
  { 
    crcUpdate();
    return f_crc$value; 
  }
  
  /// Return true if spline crc is OK
  property crcIsOk;
  read: 
  var crc = new EsCRC8(f_crc#asBinBuffer(), f_crc$value);
  { 
    return 0 == crc$value; 
  }
  
  /// Access nodes count
  property cnt;
  read: { return f_cnt$value; }
  write: 
  { 
    maxLenCheck(__value);
  
    f_cnt = __value;
    m_crcInvalid = true;
  }
}
