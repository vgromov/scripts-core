##require("../core.ess");

// create io channel && rpc master
var chnl =
 //EsChannelIoFactory::channelCreate("EsChannelIoUart");
 EsChannelIoFactory::channelCreate("EsChannelIoEkonnect");

// configure channel, assign to master
chnl$device = "60001-00005-12";
//chnl$port = "\\\\?\\COM4";
chnl$baud = 9600;

// power config stuff
function configurePowerOn(chnl)
{
  // EsScriptDebug::log("configurePowerOn");
  chnl.devicePowerSet(true);
  EsThreadWorker::sleep(100);
}

function configurePowerOff(chnl)
{
  // EsScriptDebug::log("configurePowerOff");
  chnl.devicePowerSet(false);
  EsThreadWorker::sleep(100);
}
      
function configureBoot(chnl)
{
  // EsScriptDebug::log("configureBoot");
  chnl.deviceProgrammingModeSet(true);
  EsThreadWorker::sleep(100);   
}

function configureNormal(chnl)
{
  // EsScriptDebug::log("configureBoot");
  chnl.deviceProgrammingModeSet(false);
  EsThreadWorker::sleep(200);   
}

configurePowerOff(chnl);
configureNormal(chnl);
configurePowerOn(chnl);

var supportedRpcs, rpcMaster = new EsRpcMaster();
rpcMaster$channel = chnl;
rpcMaster$packetRetries = 1;

// activate io
rpcMaster.activate();
if( rpcMaster.ping() )
{
  supportedRpcs = rpcMaster.getImplementedRPCs();
  if( EsRpcStdId$$SHUTDOWN in supportedRpcs )
  {
    EsScriptDebug::log("Sending shutdown command...");
    rpcMaster.VOID_Call(EsRpcStdId$$SHUTDOWN);
    configurePowerOff(chnl);
    configureBoot(chnl);
  }
  // Wait until device detects power off, and shuts down OK
  EsThreadWorker::sleep(2000);
  configurePowerOn(chnl);
}
else
{
  EsScriptDebug::log("No PING m_response...");
  configurePowerOff(chnl);
  configureBoot(chnl);
  configurePowerOn(chnl);
}

// Configure channel for STM32 BL protocol
EsScriptDebug::log("Configuring channel for BL");
chnl.close();
chnl$baud = 115200;
chnl$parity = 
// EsUartIoParityEnum$$parityEven;
 EsEkonnectIoParityEnum$$parityEven;
chnl.open();

/// Known STM32 ACKs and NACKs
const c_stm32ACKs     = [0x75, 0x79];
const c_stm32NACKs    = [0x3F, 0x1F];

##require(stm32McuDb.ess);

// ACK | NACK response types
enum EsStm32response
{
  None    = -1;
  Unknown = 0;
  ACK     = 1;
  NACK    = 2;
}

// Command codes indexes
enum EsStm32cmd
{
  VerAndCapsGet   = 0, "Get Bootloader version and supported commands";
  VerAndRprotGet  = 1, "Get bootloader version and read protection status";
  ChipIdGet       = 2, "Get chip ID";
  MemRead         = 3, "Read up to 256 bytes of memory at specified address";
  GoTo            = 4, "Jump to user code located at specified address";
  MemWrite        = 5, "Write up to 256 bytes to the specified address";
  MemErase        = 6, "Erase specified amount of flash memory pages";
  WriteProtSet    = 7, "Set flash sector(s) write protection";
  WriteProtClear  = 8, "Clear flash sector(s) write protection";
  ReadProtSet     = 9, "Set flash sector(s) read protection";
  ReadProtClear   = 10,"Clear flash sector(s) read protection";
}

object EsMcuprogStm32
{
	var m_flags,
			m_synched,
			m_chipId, 
	    m_bootVer,
	    m_bootId,
	    m_cmdsAvail, 
	    m_ack, 
	    m_nack,
	    m_recentCmd, 
			m_rprotOff,
			m_rprotOn,    
	    m_request, 
	    m_response,
	    m_moniker;

  /// Reset some fields to initial values, as if bootloader was never contacted
  function reset()
  {
		m_synched = false;
    m_cmdsAvail = B"\0\1\2"; // At least, GET commands should always be there
		m_chipId = null; 
    m_bootVer = null;
    m_bootId = null;
    m_ack = null; 
    m_nack = null; 
    m_recentCmd = null;
    m_rprotOff = null;
    m_rprotOn = null;
  }
      
  /// Default constructor    
  new(flags, moniker)
  {
		m_flags = flags#asULong();
		m_moniker = moniker;
		reset();
  }    
      
  /// Return true if commands available were read,
  /// and available memory erase command is standard, or an extended one
  ///
	function haveExtendedErase()
	{
	  return m_cmdsAvail.countGet() > EsStm32cmd$$MemErase &&
	    0x44 == m_cmdsAvail[EsStm32cmd$$MemErase];
	}
	
	/// Return true if the second NACK may be expected for the recent command
	function expectSecondNack()
	{
    if( m_synched && 
        !m_chipId#isEmpty() &&
        !m_bootVer#isEmpty() &&
        m_cmdsAvail.countGet() > EsStm32cmd$$MemWrite &&
        !m_recentCmd#isEmpty() &&
        ( m_recentCmd == m_cmdsAvail[EsStm32cmd$$MemWrite] || 
          m_recentCmd == m_cmdsAvail[EsStm32cmd$$MemWrite] 
        ) )
    {
      
      
    }    
    
    return false;
	}
	
	/// Read ACK or NACK from comm channel
	function ackOrNackRead(chnl, tmo)
	{
	  m_response = chnl.bytesGet(1, tmo);
	  if( m_response.countGet() )
	  {
      // EsScriptDebug::log("ACK or NACK response: %0X", m_response[0]);  
      // Define ACK and NACK values to be used in BL, the first time known ACK is read
      if( m_ack#isEmpty() && 
          m_response[0] in c_stm32ACKs )
      {
        m_ack = m_response[0];
        if( c_stm32ACKs[0] == m_ack )
          m_nack = c_stm32NACKs[0];
        else
          m_nack = c_stm32NACKs[1];
			}
			        
	    if( !m_ack#isEmpty() && m_ack == m_response[0] )
	      return EsStm32response$$ACK;
	    else if( !m_nack#isEmpty() && m_nack == m_response[0] )
	    {
	      if( expectSecondNack() )
	        chnl.bytesGet(1, tmo);
	        
	      return EsStm32response$$NACK;
	    }
	    else
	      return EsStm32response$$Unknown;
	  }
	  
	  return EsStm32response$$None;
	}
	
	/// Synchronize with bootloader
	function syncWithBootloader(chnl, syncRetries, doThrow)
	var cnt = 0;
	{
	  if( !m_booted )
	  {
	    m_request = B"\x7F";
	  
	    while( cnt < syncRetries )
	    {
	      if( 1 == chnl.bytesPut(m_request, 10) &&
	          EsStm32response$$ACK == ackOrNackRead(chnl, 1000) )
	      {
	        // Skip any extra IN bytes which device may send after entering BL
	        while( chnl.bytesGet(m_request, 500) );
	        m_booted = true;
	        break;
	      }
	    
	      ++cnt;
	    }
	  
	    if( !m_booted && doThrow )
	      throw "Could not synchronize with bootloader";
	  }
	}
	
	/// Helper- calculate XOR checksum for cnt bytes from buff, using init as a starting value
	function xorBuff(init, buff, cnt)
	var idx = 0, result = init#asByte();
	{
	  while(idx < cnt)
	    result ^= buff[idx++]#asByte();   
	
	  return result#asByte();
	}
	
	/// Helper- send BL command over the channel
	function cmdWrite(chnl, cmd, tmo)
	var result = EsStm32response$$None;
	{
		m_recentCmd = cmd;
	  m_request.countSet(2);
	  m_request[0] = cmd;
	  m_request[1] = xorBuff(0xFF, m_request, 1);
		
	  //EsScriptDebug::log("CMD request:"); EsScriptDebug::log(m_request);
	  if( 2 == chnl.bytesPut(m_request, tmo) )
	    result = ackOrNackRead(chnl, tmo);
	
	  return result;
	}
	
	/// Read BL code version and available commands
	function bootcodeVerAndCmdsRead(chnl, tmo)
	var cnt;
	{
	  if( EsStm32response$$ACK == cmdWrite(chnl, 0x00, tmo) )
	  {
	    m_response = chnl.bytesGet(1, tmo);
	    if( m_response.countGet() )
	    {
	      cnt = m_response[0]+1;  
	      m_response = chnl.bytesGet(cnt, tmo + chnl.txTimeEstimateGet(cnt));
	      if( cnt == m_response.countGet() )
	      {
	        m_bootVer = m_response[0];
	        m_cmdsAvail = m_response#sliceGet(1, cnt-1);
	        
	        return ackOrNackRead(chnl, tmo);
	      }
	    }
	  }
	  
	  return EsStm32response$$None;
	}
	
	/// Read BL code version and rprot status
	function bootcodeVerAndProtRead(chnl, tmo)
	{
	  if( EsStm32response$$ACK == cmdWrite(chnl, 0x01, tmo) )
	  {
	    m_response = chnl.bytesGet(3, tmo + chnl.txTimeEstimateGet(3));
	    if( 3 == m_response.countGet() )
	    {
	      m_bootVer = m_response[0];
	      m_rprotOff = m_response[1];
	      m_rprotOn = m_response[2];
	      return ackOrNackRead(chnl, tmo);
	    }
	  }
	  
	  return EsStm32response$$None;  
	}
	
	/// Read chip ID
	function chipIdRead(chnl, tmo)
	var cnt;
	{
	  if( EsStm32response$$ACK == cmdWrite(chnl, 0x02, tmo) )
	  {
	    m_response = chnl.bytesGet(1, tmo);
	    if( m_response.countGet() )
	    {
	      cnt = m_response[0]+1;    
	      m_response = chnl.bytesGet(cnt, tmo + chnl.txTimeEstimateGet(cnt));
	      if( cnt == m_response.countGet() )
	      {
	        m_response#reverse();
	        m_chipId = m_response#asULong();
	        
	        return ackOrNackRead(chnl, tmo);
	      }
	    }
	  }
	  
	  return EsStm32response$$None;  
	}
	
	/// Jump to the specified memory address
	function goTo(chnl, addr, tmo)
	{
	  if( EsStm32response$$ACK == cmdWrite(chnl, m_cmdsAvail[EsStm32cmd$$GoTo], tmo) )
	  {
	    // TODO: validate address for specific device
	    // Send address, MSB to LSB + checksum
	    m_request = addr#asULong()#asBinBuffer();
	    m_request#reverse();
	    m_request += xorBuff(0, m_request, 4);
	    if( 5 == chnl.bytesPut(m_request, tmo) &&
	        EsStm32response$$ACK == ackOrNackRead(chnl, tmo) )
	    {
	      return ackOrNackRead(chnl, tmo);
	    }
	  }
	  
	  return EsStm32response$$None;
	}
	
	/// Request memory read
	function memRead(chnl, addr, cnt, tmo)
	{
	  if( 0 >= cnt || cnt > 255 )
	    throw "Could not read more, than 255 bytes per packet";
	
	  if( EsStm32response$$ACK == cmdWrite(chnl, m_cmdsAvail[EsStm32cmd$$MemRead], tmo) )
	  {
	    // TODO: validate address for specific device
	    // Send address, MSB to LSB + checksum
	    m_request = addr#asULong()#asBinBuffer();
	    m_request#reverse();
	    m_request += xorBuff(0, m_request, 4);
	    if( 5 == chnl.bytesPut(m_request, tmo) &&
	        EsStm32response$$ACK == ackOrNackRead(chnl, tmo) )
	    {
	      m_request#countSet(2);
	      m_request[0] = cnt-1;
	      m_request[1] = xorBuff(0xFF, m_request, 1);
	      if( 2 == chnl.bytesPut(m_request, tmo) &&
	          EsStm32response$$ACK == ackOrNackRead(chnl, tmo) )
	      {
	        m_response = chnl.bytesGet(cnt+1, tmo+chnl.txTimeEstimateGet(cnt+1));
	        if( cnt == m_response#countGet() )
	          return EsStm32response$$ACK;
	      }
	    }
	  }
	  
	  return EsStm32response$$None;    
	}
	
	/// Request memory write
	function memWrite(chnl, addr, data, tmo)
	var cnt = data#countGet();
	{
	  if( 0 >= cnt || cnt > 255 )
	    throw "Could not write more, than 255 bytes per packet";
	
	  if( cnt % 4 )
	    throw "Write packet length must be multiple of 4";
	
	  if( EsStm32response$$ACK == cmdWrite(chnl, m_cmdsAvail[EsStm32cmd$$MemWrite], tmo) )
	  {
	    // TODO: validate address for specific device
	    // Send address, MSB to LSB + checksum
	    m_request = addr#asULong()#asBinBuffer();
	    m_request#reverse();
	    m_request += xorBuff(0, m_request, 4);
	    if( 5 == chnl.bytesPut(m_request, tmo) &&
	        EsStm32response$$ACK == ackOrNackRead(chnl, tmo) )
	    {
	      m_request#countSet(1);
	      m_request[0] = cnt-1;
	      m_request += data;
	      m_request += xorBuff(0, m_request, cnt+1);
	      if( cnt+2 == chnl.bytesPut(m_request, tmo+chnl.txTimeEstimateGet(cnt+2)) )
	      {
	        return ackOrNackRead(chnl, tmo);
	      }
	    }
	  }
	  
	  return EsStm32response$$None;    
	}
	
	/// Request memory deletion
	function memErase(chnl, data, tmo)
	{
	  if( EsStm32response$$ACK == cmdWrite(chnl, m_cmdsAvail[EsStm32cmd$$MemErase], tmo) )
	  {
	    // Handle data depending on erase command flavour
	    if( haveExtendedErase() )
	    {
	    }
	    else
	    {
	    }
	  }
	
	  return EsStm32response$$None;
	}
}

/// TEST:
syncWithBootloader(chnl, 10, false);
if( m_booted )
{
  EsScriptDebug::log("Bootloader entered");
  if( EsStm32response$$ACK == bootcodeVerAndCmdsRead(chnl, 1000) )
  {
    EsScriptDebug::log("Bootcode ver: %0X", m_bootVer);
    EsScriptDebug::log("Supported commands:");
    EsScriptDebug::log(m_cmdsAvail);
  }
  
  if( EsStm32response$$ACK == bootcodeVerAndProtRead(chnl, 1000) )
  {
    EsScriptDebug::log("Bootcode ver: %0X", m_bootVer);
    EsScriptDebug::log("Read prot. on: %d; off: %d", m_rprotOn, m_rprotOff);
  }

  if( EsStm32response$$ACK == chipIdRead(chnl, 1000) )
    EsScriptDebug::log("Chip ID: %0X", m_chipId);
  
  if( EsStm32response$$ACK == memRead(chnl, 0x08000800, 16, 1000) )
  {
    EsScriptDebug::log("Memory read:");
    EsScriptDebug::log(m_response);
  }
}
else
  EsScriptDebug::log("Bootloader not entered");

configurePowerOff(chnl);
configureNormal(chnl);
configurePowerOn(chnl);
