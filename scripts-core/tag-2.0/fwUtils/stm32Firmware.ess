##require("../core.ess");

// create io channel && rpc master
var chnl =
 //EsChannelIoFactory::channelCreate("EsChannelIoUart");
 EsChannelIoFactory::channelCreate("EsChannelIoEkonnect");

// configure channel, assign to master
chnl$device = "60001-00005-12";
//chnl$port = "\\\\?\\COM4";
chnl$baud = 9600;

// power config stuff
function configurePowerOn(chnl)
{
  // EsScriptDebug::log("configurePowerOn");
  chnl.devicePowerSet(true);
  EsThreadWorker::sleep(100);
}

function configurePowerOff(chnl)
{
  // EsScriptDebug::log("configurePowerOff");
  chnl.devicePowerSet(false);
  EsThreadWorker::sleep(100);
}
      
function configureBoot(chnl)
{
  // EsScriptDebug::log("configureBoot");
  chnl.deviceProgrammingModeSet(true);
  EsThreadWorker::sleep(100);   
}

function configureNormal(chnl)
{
  // EsScriptDebug::log("configureBoot");
  chnl.deviceProgrammingModeSet(false);
  EsThreadWorker::sleep(200);   
}

configurePowerOff(chnl);
configureNormal(chnl);
configurePowerOn(chnl);

var supportedRpcs, rpcMaster = new EsRpcMaster();
rpcMaster$channel = chnl;
rpcMaster$packetRetries = 1;

// activate io
rpcMaster.activate();
if( rpcMaster.ping() )
{
  supportedRpcs = rpcMaster.getImplementedRPCs();
  if( EsRpcStdId$$SHUTDOWN in supportedRpcs )
  {
    EsScriptDebug::log("Sending shutdown command...");
    rpcMaster.VOID_Call(EsRpcStdId$$SHUTDOWN);
    configurePowerOff(chnl);
    configureBoot(chnl);
  }
  // Wait until device detects power off, and shuts down OK
  EsThreadWorker::sleep(2000);
  configurePowerOn(chnl);
}
else
{
  EsScriptDebug::log("No PING m_response...");
  configurePowerOff(chnl);
  configureBoot(chnl);
  configurePowerOn(chnl);
}

// Configure channel for STM32 BL protocol
EsScriptDebug::log("Configuring channel for BL");
chnl.close();
chnl$baud = 115200;
chnl$parity = 
// EsUartIoParityEnum$$parityEven;
 EsEkonnectIoParityEnum$$parityEven;
chnl.open();

// BL Query byte
var m_chipId, 
    m_bootVer,
    m_rprotOn = 0,
    m_rprotOff = 0,
    m_cmdsAvail = B"\0\1\2", // At least, GET commands should always be there 
    m_ack = 0x79, 
    m_nack = 0x1F, 
    m_booted = false,
    m_request, 
    m_response;

// ACK | NACK response types
enum EsStm32response
{
  None    = -1;
  Unknown = 0;
  ACK     = 1;
  NACK    = 2;
}

// Command codes indexes
enum EsStm32cmd
{
  VerAndCapsGet   = 0, "Get Bootloader version and supported commands";
  VerAndRprotGet  = 1, "Get bootloader version and read protection status";
  ChipIdGet       = 2, "Get chip ID";
  MemRead         = 3, "Read up to 256 bytes of memory at specified address";
  GoTo            = 4, "Jump to user code located at specified address";
  MemWrite        = 5, "Write up to 256 bytes to the specified address";
  MemErase        = 6, "Erase specified amount of flash memory pages";
  WriteProtSet    = 7, "Set flash sector(s) write protection";
  WriteProtClear  = 8, "Clear flash sector(s) write protection";
  ReadProtSet     = 9, "Set flash sector(s) read protection";
  ReadProtClear   = 10,"Clear flash sector(s) read protection";
}

function haveExtendedErase()
{
  return m_cmdsAvail.countGet() > EsStm32cmd$$MemErase &&
    0x44 == m_cmdsAvail[EsStm32cmd$$MemErase];
}

function ackOrNackRead(chnl, tmo)
{
  m_response = chnl.bytesGet(1, tmo);
  if( m_response.countGet() )
  {
    EsScriptDebug::log("ACK or NACK response: %0X", m_response[0]);    

    if( m_ack == m_response[0] )
      return EsStm32response$$ACK;
    else if( m_nack == m_response[0] )
    {
      // TODO: depending on device
      //if( dblNack )
      //  chnl.bytesGet(1, 10);
        
      return EsStm32response$$NACK;
    }
    else
      return EsStm32response$$Unknown;
  }
  
  return EsStm32response$$None;
}

function syncWithBootloader(chnl, syncRetries, doThrow)
var cnt = 0;
{
  if( !m_booted )
  {
    m_request = B"\x7F";
  
    while( cnt < syncRetries )
    {
      if( 1 == chnl.bytesPut(m_request, 10) &&
          EsStm32response$$ACK == ackOrNackRead(chnl, 1000) )
      {
        // Skip any extra IN bytes which device may send after entering BL
        while( chnl.bytesGet(m_request, 500) );
        m_booted = true;
        break;
      }
    
      ++cnt;
    }
  
    if( !m_booted && doThrow )
      throw "Could not synchronize with bootloader";
  }
}

function xorBuff(init, buff, cnt)
var idx = 0, result = init#asByte();
{
  while(idx < cnt)
    result ^= buff[idx++]#asByte();   

  return result#asByte();
}

function cmdWrite(chnl, cmd, tmo)
var result = EsStm32response$$None;
{
  m_request.countSet(2);
  m_request[0] = cmd;
  m_request[1] = xorBuff(0xFF, m_request, 1);

  EsScriptDebug::log("CMD request:"); EsScriptDebug::log(m_request);
  if( 2 == chnl.bytesPut(m_request, tmo) )
    result = ackOrNackRead(chnl, tmo);

  return result;
}

function bootcodeVerAndCmdsRead(chnl, tmo)
var cnt;
{
  if( EsStm32response$$ACK == cmdWrite(chnl, 0x00, tmo) )
  {
    m_response = chnl.bytesGet(1, tmo);
    if( m_response.countGet() )
    {
      cnt = m_response[0]+1;  
      m_response = chnl.bytesGet(cnt, tmo + chnl.txTimeEstimateGet(cnt));
      if( cnt == m_response.countGet() )
      {
        m_bootVer = m_response[0];
        m_cmdsAvail = m_response#sliceGet(1, cnt-1);
        
        return ackOrNackRead(chnl, tmo);
      }
    }
  }
  
  return EsStm32response$$None;
}

function bootcodeVerAndProtRead(chnl, tmo)
{
  if( EsStm32response$$ACK == cmdWrite(chnl, 0x01, tmo) )
  {
    m_response = chnl.bytesGet(3, tmo + chnl.txTimeEstimateGet(3));
    if( 3 == m_response.countGet() )
    {
      m_bootVer = m_response[0];
      m_rprotOff = m_response[1];
      m_rprotOn = m_response[2];
      return ackOrNackRead(chnl, tmo);
    }
  }
  
  return EsStm32response$$None;  
}

function chipIdRead(chnl, tmo)
var cnt;
{
  if( EsStm32response$$ACK == cmdWrite(chnl, 0x02, tmo) )
  {
    m_response = chnl.bytesGet(1, tmo);
    if( m_response.countGet() )
    {
      cnt = m_response[0]+1;    
      m_response = chnl.bytesGet(cnt, tmo + chnl.txTimeEstimateGet(cnt));
      if( cnt == m_response.countGet() )
      {
        m_response#reverse();
        m_chipId = m_response#asULong();
        
        return ackOrNackRead(chnl, tmo);
      }
    }
  }
  
  return EsStm32response$$None;  
}

function goTo(chnl, addr, tmo)
{
  if( EsStm32response$$ACK == cmdWrite(chnl, m_cmdsAvail[EsStm32cmd$$GoTo], tmo) )
  {
    // TODO: validate address for specific device
    // Send address, MSB to LSB + checksum
    m_request = addr#asULong()#asBinBuffer();
    m_request#reverse();
    m_request += xorBuff(0, m_request, 4);
    if( 5 == chnl.bytesPut(m_request, tmo) &&
        EsStm32response$$ACK == ackOrNackRead(chnl, tmo) )
    {
      return ackOrNackRead(chnl, tmo);
    }
  }
  
  return EsStm32response$$None;
}

function memRead(chnl, addr, cnt, tmo)
{
  if( 0 >= cnt || cnt > 255 )
    throw "Could not read more, than 255 bytes per packet";

  if( EsStm32response$$ACK == cmdWrite(chnl, m_cmdsAvail[EsStm32cmd$$MemRead], tmo) )
  {
    // TODO: validate address for specific device
    // Send address, MSB to LSB + checksum
    m_request = addr#asULong()#asBinBuffer();
    m_request#reverse();
    m_request += xorBuff(0, m_request, 4);
    if( 5 == chnl.bytesPut(m_request, tmo) &&
        EsStm32response$$ACK == ackOrNackRead(chnl, tmo) )
    {
      m_request#countSet(2);
      m_request[0] = cnt-1;
      m_request[1] = xorBuff(0xFF, m_request, 1);
      if( 2 == chnl.bytesPut(m_request, tmo) &&
          EsStm32response$$ACK == ackOrNackRead(chnl, tmo) )
      {
        m_response = chnl.bytesGet(cnt+1, tmo+chnl.txTimeEstimateGet(cnt+1));
        if( cnt == m_response#countGet() )
          return EsStm32response$$ACK;
      }
    }
  }
  
  return EsStm32response$$None;    
}

function memWrite(chnl, addr, data, tmo)
var cnt = data#countGet();
{
  if( 0 >= cnt || cnt > 255 )
    throw "Could not write more, than 255 bytes per packet";

  if( cnt % 4 )
    throw "Write packet length must be multiple of 4";

  if( EsStm32response$$ACK == cmdWrite(chnl, m_cmdsAvail[EsStm32cmd$$MemWrite], tmo) )
  {
    // TODO: validate address for specific device
    // Send address, MSB to LSB + checksum
    m_request = addr#asULong()#asBinBuffer();
    m_request#reverse();
    m_request += xorBuff(0, m_request, 4);
    if( 5 == chnl.bytesPut(m_request, tmo) &&
        EsStm32response$$ACK == ackOrNackRead(chnl, tmo) )
    {
      m_request#countSet(1);
      m_request[0] = cnt-1;
      m_request += data;
      m_request += xorBuff(0, m_request, cnt+1);
      if( cnt+2 == chnl.bytesPut(m_request, tmo+chnl.txTimeEstimateGet(cnt+2)) )
      {
        return ackOrNackRead(chnl, tmo);
      }
    }
  }
  
  return EsStm32response$$None;    
}

// Depending the data
function memErase(chnl, data, tmo)
{
  if( EsStm32response$$ACK == cmdWrite(chnl, m_cmdsAvail[EsStm32cmd$$MemErase], tmo) )
  {
    // Handle data depending on erase command flavour
    if( haveExtendedErase() )
    {
    }
    else
    {
    }
  }

  return EsStm32response$$None;
}

syncWithBootloader(chnl, 10, false);
if( m_booted )
{
  EsScriptDebug::log("Bootloader entered");
  if( EsStm32response$$ACK == bootcodeVerAndCmdsRead(chnl, 1000) )
  {
    EsScriptDebug::log("Bootcode ver: %0X", m_bootVer);
    EsScriptDebug::log("Supported commands:");
    EsScriptDebug::log(m_cmdsAvail);
  }
  
  if( EsStm32response$$ACK == bootcodeVerAndProtRead(chnl, 1000) )
  {
    EsScriptDebug::log("Bootcode ver: %0X", m_bootVer);
    EsScriptDebug::log("Read prot. on: %d; off: %d", m_rprotOn, m_rprotOff);
  }

  if( EsStm32response$$ACK == chipIdRead(chnl, 1000) )
    EsScriptDebug::log("Chip ID: %0X", m_chipId);
  
  if( EsStm32response$$ACK == memRead(chnl, 0x08000800, 16, 1000) )
  {
    EsScriptDebug::log("Memory read:");
    EsScriptDebug::log(m_response);
  }
}
else
  EsScriptDebug::log("Bootloader not entered");

configurePowerOff(chnl);
configureNormal(chnl);
configurePowerOn(chnl);
