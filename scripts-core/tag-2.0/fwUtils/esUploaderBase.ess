const c_dumbShutdownTmo = 50;

const ES_EVTC_FWUPLOADER = "ES_EVTC_FWUPLOADER";

// Base uploader object implementation
//
object EsUploaderBase
{
  var m_moniker, 
      m_defaultBaud,
      m_preferredUploadBaud,
      m_savedBaud,
      m_cancelled,
      m_evtHandler;
     
  new()
  {
    m_cancelled = false;
    m_evtHandler = EsEventHandler::createAsync(
      this,
      ES_EVTC_FWUPLOADER
    );
    m_evtHandler$active = false;
  }  
    
  // Event handling
  function onEvent(evt)
  {
    if( ES_EVTC_FWUPLOADER == evt$category && 
        0 == evt$id 
    )
      m_cancelled = true;
  }
    
  // Common channel power manipulators, to augment entering boot mode
  //
  function configurePowerOn(chnl)
  {
    if( chnl.hasMethod("devicePowerSet", 1) )
    {  
      //EsScriptDebug::log("configurePowerOn");
      chnl.devicePowerSet(true);
      EsThreadWorker::sleep(200);
    }
  }

  function configurePowerOff(chnl)
  {
    if( chnl.hasMethod("devicePowerSet", 1) )
    {  
      //EsScriptDebug::log("configurePowerOff");
      chnl.deviceProgrammingModeSet(true);   //< Nullify programming pin anyway, to allow device to power off cleanly
      chnl.devicePowerSet(false);
      EsThreadWorker::sleep(500);
    }
  }
  
  function devicePowerOnInNormalMode(chnl)
  {
    if( chnl.hasMethod("devicePowerSet", 1) )
    {
      chnl.open();
      configurePowerOff(chnl);
      chnl.deviceProgrammingModeSet(false);
      configurePowerOn(chnl);
      chnl.close();
    }
  }
  
  function devicePowerOnInBootMode(chnl)
  {
    if( chnl.hasMethod("devicePowerSet", 1) )
    {  
      chnl.open();
      configurePowerOff(chnl);
      configurePowerOn(chnl);
      chnl.close();
    }
  }
  
  /// Overridable FW programmer object creation. To be implemented in 
  /// derived objects
  ///
  
  /// In deriver objects, this method must create and return an instance of 
  /// device-specific programmer object
  ///
  function programmerCreate()
  {
    return null;    
  }

  /// This method prepares channel for bootloader communications, if needed.
  /// Some bootloaders may use non-default parity, byte size, etc.
  ///
  function chnlPrepareForBootloader(chnl)
  {
    //EsScriptDebug::log("chnlPrepareForBootloader");
    chnl$baud = m_preferredUploadBaud;  
  }
    
  // Restore channel settings, appicable for normal (ES-RPC) communications,
  // using default baudrate
  function chnlPrepareForDefaultNormalComm(chnl)
  {
    //EsScriptDebug::log("chnlPrepareForDefaultNormalComm");
    chnl$baud = m_defaultBaud;
  }  

  // Restore channel settings, appicable for normal (ES-RPC) communications,
  // using saved baudrate
  function chnlPrepareForNormalComm(chnl)
  {
    //EsScriptDebug::log("chnlPrepareForNormalComm");
    chnl$baud = m_savedBaud;
  }  
  
  /// Method to be called upon firmware upload completion
  ///
  function completeUpload(chnl)
  {
    //EsScriptDebug::log("Completing upload");
  
    // Restore baud
    chnl.close();
    chnlPrepareForNormalComm(chnl);
    // restore normal power
    devicePowerOnInNormalMode(chnl);
  }
  
  // Configure and ebnter boot mode, before programming device with ISP
  function configureForBoot(programmer, rpcMaster, supportedRpcs)
  {  
    return false;
  }
    
  function checkIfStartedInBoot(chnl, programmer)
  var progressTask = new EsProgressMonitorTask("checkIfStartedInBoot"), deviceIsInBootMode = false;
  {
		progressTask.attachTo(__scriptHost$progressMonitor);
    progressTask.pulse("Checking empty device...");

    //EsScriptDebug::log("Preparing for default boot communication");
    // Prepare channel for bootloader communication
    chnlPrepareForBootloader(chnl);
    // power device normally
    devicePowerOnInNormalMode(chnl);
    
    // Check if we're in bootloader mode (empty chip), trying to sync with bootloader at once
    chnl.open();
    //EsScriptDebug::log("Checking if we're empty, and, thus, booted by default");
    deviceIsInBootMode = programmer.checkIfInBoot(chnl);
    chnl.close();  
    
    return deviceIsInBootMode;
  }  
  
  function deviceDumbShutdownWait(chnl, tmo)
  var progressTask = new EsProgressMonitorTask("waitingForShutdownOnTmo");
  {
		progressTask.attachTo(__scriptHost$progressMonitor);
    progressTask.initialize("Waiting for device to shut down on timeout...", tmo*1000, tmo*1000 );
    
    chnlPrepareForBootloader(chnl);
    configurePowerOff(chnl);
    
    m_cancelled = false;
    m_evtHandler$active = true;
    while( !__scriptHost$aborting && tmo > 0 && !m_cancelled )
    {    
      EsThreadWorker::sleep(100);
      m_evtHandler.eventProcess();

      tmo -= 100;
      progressTask$position = tmo;
    }
    m_evtHandler$active = false;
      
    configurePowerOn(chnl);    
  }
  
  // Upload firmware 
  function upload(rpcMaster)
  var programmer = programmerCreate();
  var chnl = rpcMaster$channel, swInfo,
    supportedRpcs, deviceIsInBootMode = false, alreadySynched = false;
  {  
    rpcMaster.deactivate();
    m_savedBaud = chnl$baud;

    deviceIsInBootMode = checkIfStartedInBoot(chnl, programmer);
    alreadySynched = deviceIsInBootMode;
    
    // EsScriptDebug::log("In boot mode: %s", deviceIsInBootMode);
    if( !deviceIsInBootMode )
    {
      //EsScriptDebug::log("Preparing for RPC-controlled communication");

      // Prepare for normal communications
      chnlPrepareForDefaultNormalComm(chnl);
      // Power device on in normal mode
      devicePowerOnInNormalMode(chnl);
      // Wait extra time to allow device to boot-up
      EsThreadWorker::sleep(2000);
      rpcMaster.activate();
      
      try
      {
        //EsScriptDebug::log("Getting implemented RPCs");
        
        supportedRpcs = rpcMaster.getImplementedRPCs();
        // if SW_INFO is supported, read it (we'll need current fw crc to set-up previous fw crc)
        if( EsRpcStdId$$SW_INFO_GET in supportedRpcs &&
            m_moniker.hasProperty("fwPrevCrc") )
        {
          swInfo = new EsSoftwareInfo();
          swInfo$buffer = rpcMaster.esBA_Call(EsRpcStdId$$SW_INFO_GET);
          m_moniker.propertySet("fwPrevCrc", swInfo$fwSoftwareInfo$crcInfo$crcCurrent);
        }
        rpcMaster.deactivate();
        
        //EsScriptDebug::log("Implemented RPCs acquired");
      }
      catch
      {
        // error ocurred during the most basic device query
        // device may be already in boot mode
        rpcMaster.deactivate();
      }
      
      //EsScriptDebug::log("Trying to enter boot with RPC shutdown");
      deviceIsInBootMode = configureForBoot(programmer, rpcMaster, supportedRpcs);
    }
     
    chnl.close();
    if( !deviceIsInBootMode )
    {
      //EsScriptDebug::log("Performing dumb shutdown");
      deviceDumbShutdownWait(chnl, c_dumbShutdownTmo);
    }
    chnl.open();

    try
    {
      //EsScriptDebug::log("programmer.program with alreadySynched=%s", alreadySynched ? "Yes" : "No");
      
      programmer.program(chnl, alreadySynched);
      completeUpload(chnl);
    }
    catch
    {
      completeUpload(chnl);
      rethrow;
    }
  }
  
  property moniker;
  read: { return m_moniker; }  
}
