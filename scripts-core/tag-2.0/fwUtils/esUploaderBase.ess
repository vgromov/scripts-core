// Base uploader object implementation
//
object EsUploaderBase
{
  var m_moniker, 
      m_defaultBaud,
      m_preferredUploadBaud,
      m_savedBaud;
     
  // Common channel power manipulators, t augmen entering boot mode
  //
  function configurePowerOn(chnl)
  {
    chnl.devicePowerSet(true);
    EsThreadWorker::sleep(200);
  }

  function configurePowerOff(chnl)
  {
    chnl.devicePowerSet(false);
    chnl.deviceProgrammingModeSet(true);   //< Nullify programming pin anyway, to allow device to power off cleanly
    EsThreadWorker::sleep(200);
  }
  
  function devicePowerOnInNormalMode(chnl)
  {
    if( chnl.hasMethod("devicePowerSet", 1) )
    {
      chnl.open();
      configurePowerOff(chnl);
      chnl.deviceProgrammingModeSet(false);
      configurePowerOn(chnl);
      chnl.close();
    }
  }
  
  function devicePowerOnInBootMode(chnl)
  {
    if( chnl.hasMethod("devicePowerSet", 1) )
    {  
      chnl.open();
      configurePowerOff(chnl);
      configurePowerOn(chnl);
      chnl.close();
    }
  }
  
  /// Overridable FW programmer object creation. To be implemented in 
  /// derived objects
  ///
  
  /// In deriver objects, this method must create and return an instance of 
  /// device-specific programmer object
  ///
  function programmerCreate()
  {
    return null;    
  }

  /// This method prepares channel for bootloader communications, if needed.
  /// Some bootloaders may use non-default parity, byte size, etc.
  ///
  function chnlPrepareForBootloader(chnl)
  {
    chnl$baud = m_preferredUploadBaud;  
  }
    
  // Restore channel settings, appicable for normal (ES-RPC) communications,
  // using default baudrate
  function chnlPrepareForDefaultNormalComm(chnl)
  {
    chnl$baud = m_defaultBaud;
  }  

  // Restore channel settings, appicable for normal (ES-RPC) communications,
  // using saved baudrate
  function chnlPrepareForNormalComm(chnl)
  {
    chnl$baud = m_savedBaud;
  }  
  
  /// Method to be called upon firmware upload completion
  ///
  function completeUpload(chnl)
  {
    // Restore baud
    chnl.close();
    chnlPrepareForNormalComm(chnl);
    // restore normal power
    devicePowerOnInNormalMode(chnl);
  }
  
  // Configure and ebnter boot mode, before programming device with ISP
  function configureForBoot(programmer, rpcMaster, supportedRpcs)
  {  
    return false;
  }
    
  function checkIfStartedInBoot(chnl, programmer)
  var progressTask = new EsProgressMonitorTask("checkIfStartedInBoot"), deviceIsInBootMode = false;
  {
		progressTask.attachTo(__scriptHost$progressMonitor);
    progressTask.pulse("Checking empty device...");

    EsScriptDebug::log("Preparing for default boot communication");
    // Prepare channel for bootloader communication
    chnlPrepareForBootloader(chnl);
    // power device normally
    devicePowerOnInNormalMode(chnl);
    
    // Check if we're in bootloader mode (empty chip), trying to sync with bootloader at once
    chnl.open();
    EsScriptDebug::log("Checking if we're empty, and, thus, booted by default");
    deviceIsInBootMode = programmer.checkIfInBoot(chnl);
    chnl.close();  
    
    return deviceIsInBootMode;
  }  
    
  // Upload firmware 
  function upload(rpcMaster)
  var programmer = programmerCreate();
  var chnl = rpcMaster$channel, swInfo,
    supportedRpcs, deviceIsInBootMode = false;
  {  
    rpcMaster.deactivate();
    m_savedBaud = chnl$baud;

    deviceIsInBootMode = checkIfStartedInBoot(chnl, programmer);
    
    // EsScriptDebug::log("In boot mode: %s", deviceIsInBootMode);
    if( !deviceIsInBootMode )
    {
      EsScriptDebug::log("Preparing for RPC-controlled communication");
      // Prepare for normal communications
      chnlPrepareForDefaultNormalComm(chnl);
      // Power device on in normal mode
      devicePowerOnInNormalMode(chnl);
      // Wait extra time to allow device to boot-up
      EsThreadWorker::sleep(2000);
      rpcMaster.activate();
      
      try
      {
//        EsScriptDebug::log("Getting implemented RPCs");
        supportedRpcs = rpcMaster.getImplementedRPCs();
        // if SW_INFO is supported, read it (we'll need current fw crc to set-up previous fw crc)
        if( EsRpcStdId$$SW_INFO_GET in supportedRpcs &&
            m_moniker.hasProperty("fwPrevCrc") )
        {
          swInfo = new EsSoftwareInfo();
          swInfo$buffer = rpcMaster.esBA_Call(EsRpcStdId$$SW_INFO_GET);
          m_moniker.propertySet("fwPrevCrc", swInfo$fwSoftwareInfo$crcInfo$crcCurrent);
        }
        rpcMaster.deactivate();
        
//        EsScriptDebug::log("Implemented RPCs acquired");
      }
      catch
      {
        // error ocurred during the most basic device query
        // device may be already in boot mode
        rpcMaster.deactivate();
      }
      
      deviceIsInBootMode = configureForBoot(programmer, rpcMaster, supportedRpcs);
    }
     
    chnl.close();
    if( !deviceIsInBootMode )
    {
      chnlPrepareForBootloader(chnl);
      devicePowerOnInBootMode(chnl);
    }
    chnl.open();

    try
    {
      programmer.program(chnl, deviceIsInBootMode);
      completeUpload(chnl);
    }
    catch
    {
      completeUpload(chnl);
      rethrow;
    }
  }
  
  property moniker;
  read: { return m_moniker; }  
}
