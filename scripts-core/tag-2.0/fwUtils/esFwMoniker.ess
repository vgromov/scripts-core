##require("core.ess");

// ekosf firmware moniker services
//
object EsFwMoniker
{
	var m_fwTypeExpected,
			m_fwIdOffs,	
			m_crpOffs, 
			m_xtalHz,
			m_binary,
			m_descr,
			m_creationDateTime,
			m_tmpId,
			m_tmpCrp,
			m_tmpFw;
			
	if( deviceIsHubFull(m_fwTypeExpected) )
	{
		property UID;
		read: { return m_tmpId$UID; }
		write: { m_tmpId.f_uid = __value; }
		
		property functionality;
		read: { return m_tmpId$functionality; }
		write: { m_tmpId$functionality = __value; }
	}			

	function crpCodeExtract()
	var code;
	{
		m_binary.emptyCheck();
		m_binary.fwOffsAndSizeCheck(m_crpOffs, 4);
		code = m_binary.m_fw#sliceGet(m_crpOffs, m_crpOffs+4);
		m_tmpCrp = code#asULong();
	}
		
	function crpCodeApply()
	{
		m_binary.emptyCheck();
		m_binary.fwOffsAndSizeCheck(m_crpOffs, 4);
		m_tmpFw#replace(m_tmpCrp#asBinBuffer(), m_crpOffs);
	}
	
	function fwIdExtract()
	var id = new EsFirmwareId(m_fwTypeExpected), buff;
	{
		m_binary.emptyCheck();	
		m_binary.fwOffsAndSizeCheck(m_fwIdOffs, id$size);		
		buff = m_binary.m_fw#sliceGet(m_fwIdOffs, m_fwIdOffs+id$size);
		id$buffer = buff;
		fwIdValidate(id, m_fwTypeExpected, $type);

		m_tmpId = id;
	}

	function fwIdApply()
	{
		m_binary.emptyCheck();
		if( m_tmpId.isKindOf("EsFirmwareId") )
		{
			m_binary.fwOffsAndSizeCheck(m_fwIdOffs, m_tmpId$size);
			fwIdValidate(m_tmpId, m_fwTypeExpected, $type);
			m_tmpFw#replace(m_tmpId$buffer, m_fwIdOffs);
		}
		else
			throw EsStr::format("Wrong argument type in 'fwIdSet', expected 'EsFirmwareId', got '%s'", m_tmpId$type);
	}
			
	new(fwType, fwIdOffs, crpOffs, xtal, binary, descr, creationDateTime)
	{
		m_fwTypeExpected = fwType#asULong();
		m_fwIdOffs = fwIdOffs#asULong();
		m_crpOffs = crpOffs#asULong();
		m_xtalHz = xtal#asULong();
		m_binary = binary;
		m_tmpFw = m_binary$fw;
		crpCodeExtract();
		fwIdExtract();
		m_descr = descr#asString();
		m_creationDateTime = creationDateTime#asString();
	}
	
	// properties for fw uploader && patch manipulator
	property description;
	read: { return m_descr; }

	property creationDateTime;
	read: { return m_creationDateTime; }
	
	property devType;
	read: { return m_fwTypeExpected; }

	property devTypeName;
	read: { return m_tmpId$devTypeName; }
	
	property verMajor;
	read: { return m_tmpId$verMajor; }
	
	property verMinor;
	read: { return m_tmpId$verMinor; }

	property ver;
	read: { return m_tmpId$ver; }
	
	property year;
	read: { return m_tmpId$year; }
	write: { m_tmpId.f_serial.f_year = __value; }

	property order;
	read: { return m_tmpId$order; }
	write: { m_tmpId.f_serial.f_order = __value; }
	
	property binaryFw;
	read: 
	{ 
		crpCodeApply();
		fwIdApply();
		return m_tmpFw;
	}
	
	property binaryStartAddr;
	read: { return m_binary.m_startAddr; }
	
	property binaryOffs;
	read: { return m_binary.m_offs; }
	
	property binaryByteSize;
	read: { return m_binary$fw#countGet(); }
	
	// return firmware formatted string ready for file naming
	property safeFileName;
	read:
	var result;
	{
		result = EsStr::fromString(deviceCodeNameGet(m_tmpId.f_devType), EsStrFlag$$None);
		result += EsStr::format("_%03d%03d_%05d%02d", m_tmpId.f_fwVer.f_major, m_tmpId.f_fwVer.f_minor, m_tmpId.f_serial.f_order, m_tmpId.f_serial.f_year%100);
		if( m_tmpId.hasField("f_uid") )
			result += "_" + m_tmpId.fieldGet("f_uid").asString();
		
		return result;
	}	
}