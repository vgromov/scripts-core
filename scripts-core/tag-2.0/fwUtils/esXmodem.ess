// ESS XMODEM IO implementation
//

// XMODEM special symbols
//
enum XmodemCh {
  SOH = B'\x01', "Start of Header";
  EOT = B'\x04', "End of Transmission";
  ACK = B'\x06', "Acknowledge";
  NAK = B'\x15', "Not Acknowledge";
  ETB = B'\x17', "End of Transmission Block";
  CAN = B'\x18', "Cancel";
  EOF = B'\x1A', "End Of File";
  C   = B'C',    "CRC16 Request";
  // Quarta-specific stuff:
  PING= B'\x05', "Bootloader Ping";
}

// XMODEM packet object
//
object XmodemPacket
{
  esU8 f_hdr;
  esU8 f_num;
  esU8 f_xnum;
  esU8 f_data[128];
  esU8 f_crc8;

  new( hdr, num, data, dataoffs )
  var idx, cnt, crc = B'\0', ch;
  {
    if( !(hdr in [XmodemCh$$SOH, XmodemCh$$EOT, XmodemCh$$CAN, XmodemCh$$ETB]) )
      throw EsStr::format(
        "Invalid XMODEM packet header byte: '%s'",
        hdr
      );

    f_hdr = hdr;
    
    if( !num#isEmpty() )
      f_num = num;
    else
      f_num = 0;

    f_xnum = 255-f_num;
    
    if( data#isEmpty() || dataoffs >= data#countGet() )
    {
      idx = 0;
      ch = XmodemCh$$EOF;
      while(idx < 128)
      {
        f_data[idx++] = ch;
        crc += ch#asByte();
      }
    }
    else
    {
      cnt = data#countGet() - dataoffs;
      if( cnt > 128 )
        cnt = 128;

      for(idx = 0; idx < cnt; ++idx)
      {
        ch = data[idx + dataoffs];
        f_data[idx] = ch;
        crc += ch#asByte();
      }
      
      ch = XmodemCh$$EOF;
      while(idx < 128)
      {
        f_data[idx++] = ch;
        crc += ch#asByte();
      }
    }

    f_crc8 = crc;
  }
}
