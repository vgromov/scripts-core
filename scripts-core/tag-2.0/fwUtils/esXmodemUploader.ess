// ESS XMODEM IO implementation
//

// XMODEM special symbols
//
enum XmodemCh {
  SOH = B'\0x01', "Start of Header";
  EOT = B'\0x04', "End of Transmission";
  ACK = B'\0x06', "Acknowledge";
  NAK = B'\0x15', "Not Acknowledge";
  ETB = B'\0x17', "End of Transmission Block";
  CAN = B'\0x18', "Cancel";
  EOF = B'\0x1A', "End Of File";
  C   = B'C', "CRC16 Request";
}

// XMODEM packet object
//
object XmodemPacket
{
  esU8 f_hdr;
  esU8 f_num;
  esU8 f_xnum;
  esU8 f_data[128];
  esU8 f_crc8;

  new( hdr, num, data )
  var idx, cnt, crc = B'\0', ch;
  {
    if( !(hdr in [XmodemCh$$SOH, XmodemCh$$EOT, XmodemCh$$CAN, XmodemCh$$ETB]) )
      throw EsStr::format(
        "Invalid XMODEM packet header byte: '%s'",
        hdr
      );

    f_hdr = hdr;
    
    if( !num#isEmpty() )
      f_num = num;
    else
      f_num = 0;

    f_xnum = 255-f_num;
    
    if( data#isEmpty() )
    {
      idx = 0;
      ch = XmodemCh$$EOF;
      while(idx < 128)
      {
        f_data[idx++] = ch;
        crc += ch#asByte();
      }
    }
    else
    {
      cnt = data#countGet();
      if( cnt > 128 )
        cnt = 128;

      for(idx = 0; idx < cnt; ++idx)
      {
        ch = data[idx];
        f_data[idx] = ch;
        crc += ch#asByte();
      }
      
      ch = XmodemCh$$EOF;
      while(idx < 128)
      {
        f_data[idx++] = ch;
        crc += ch#asByte();
      }
    }

    f_crc8 = crc;
  }
}

// Radex XMODEM data IO
//
object EsRadexXmodemBootInfo 
{
  esU32 f_ver;
  esU32 f_type;
}

object EsRadexXmodemIO
{
  var m_bootInfo,
    m_chnl;
  
  new()
  {
    m_bootInfo = new EsRadexXmodemBootInfo();
  }

  function bootloaderConnect()
  {
  }

  function write()
  {
  }

  property bootVer;
  read: { return m_bootInfo.f_ver#asULong(); }

  property bootType;
  read: { return m_bootInfo.f_type#asULong(); }
}
