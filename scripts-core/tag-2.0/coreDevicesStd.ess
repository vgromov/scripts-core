// --------------------------- standard device objects
// software information
object EsSoftwareCrcInfo
{
  esU32 f_crcPrev; // previous CRC32 (as calculated by CRC32 IEEE 802.3)
  esU32 f_crcCur;   // current CRC32 (as calculated by CRC32 IEEE 802.3)
  esDT f_ts;    // CRC change timestamp
  
  property timestamp;
  read: { return f_ts; }
  write: { f_ts = __value; }

  property crcPrevious;
  read: { return f_crcPrev; }
  write: { f_crcPrev = __value#asULong(); }
  
  property crcCurrent;
  read: { return f_crcCur; }
  write: { f_crcCur = __value#asULong(); }
}

object EsFirmwareSwInfo
{
  esU8 f_name[64];
  esU8 f_file[32];
  EsSoftwareCrcInfo f_crc;
  
	function nameFromString(str)
  var idx = 0, ch, name = EsStr::toByteString(str, EsStrByteEncoding$$CP1251);
	{
    foreach( ch in name )
    {
      f_name[idx] = ch;
      ++idx;
      if( idx >= 64 )
        break;
    }
    // add zero-terminator if name string is shorter than 64 symbols, and there is no terminator at the end already
    if( idx < 64 && 0 != f_name[idx-1] )
      f_name[idx] = 0;	
	}
	
	function nameAsString()
	{
		return EsStr::fromByteString(f_name$buffer, EsStrByteEncoding$$CP1251);
	}
	
	function fileFromString(str)
	var idx = 0, ch, file = EsStr::toByteString(EsStr::toUpper(str), EsStrByteEncoding$$CP1251);
  {
    foreach( ch in file )
    {
      f_file[idx] = ch;
      ++idx;
      if( idx >= 32 )
        break;
    }
    // add zero-terminator if file string is shorter than 32 symbols, and there is no terminator at the end already
    if( idx < 32 && 0 != f_file[idx-1] )
      f_file[idx] = 0;
	}
	
	function fileAsString()
	{
		return EsStr::fromByteString(f_file$buffer, EsStrByteEncoding$$CP1251);
	}
	
/// Custom stream reader
	function streamRead(stream)
	var str, crc;
	{
		str = stream.valueRead("name", "");
		nameFromString(str);
		str = stream.valueRead("file", "");
		fileFromString(str);
		f_crc.copyFrom( stream.valueRead("crc", null) );
	}
	
/// Custom stream writer
	function streamWrite(stream)
	{
		stream.valueWrite("name", nameAsString());
		stream.valueWrite("file", fileAsString());
		stream.valueWrite("crc", f_crc);		
	}
	
/// Properties	
  property name;
  read: { return nameAsString(); }
  write: { nameFromString(__value); }
  
  property file;
  read: { return fileAsString(); }
  write: { fileFromString(__value); }

  property crcInfo;
  read: { return f_crc; }
}

/// New universal hardware and firmware info structure definition
///

/// Standard hardware configuration bits
enum EseHwConfigBitsStd
{
  BluetoothClassic  = 0x0001, "Classic Bluetooth";
  BluetoothLE       = 0x0002, "Bluetooth Low Energy";
  WiFi              = 0x0004, "Wi-Fi";
  USB               = 0x0008, "USB slave";
  Accumulator       = 0x0010, "Rechargeable battery";
}

/// Universal hardware information
//
object EseHwConfigInfo
{
/// Hardware configuration
  esU16 f_stdandard;
  esU16 f_custom;
  
/// Properties 
  property standard;
  read: { return f_standard#asULong(); }
  write: { f_standard = __value#asULong(); }
  
  property custom;
  read: { return f_custom#asULong(); }
  write: { f_custom = __value#asULong(); }
}

/// Universal 64 byte firmware information
///
object EseFwInfo
  @fixedSize = 64;
  @help = "Universal firmware and hardware identification object";
{
  /// Device type
  esU16 f_type;
    @help = "Device type (model) id";
    
  /// Order
  esU32 f_order;
  /// Year
  esU16 f_year;
  /// Month
  esU8 f_month;
  /// Day of month
  esU8 f_day;
  /// Version
  EseVerInfo f_ver;
  /// Country code, as in ISO 3166-1-numeric 
  esU16 f_countryCode;
  /// Hardware configuration
  EseHwConfigInfo f_hwConfig;
  
  /// Services
  ///
  
  function comparePartial(other, flags)
  var result = -1;
  {
    if( other.isKindOf("EseFwInfo") )
    {
      if( f_type > other.f_type )
        result = 1;
      else if( f_type == other.f_type )
        result = 0;
        
      if( 0 == result && (flags & EsFirmwareIdCmpFlag$$Serial))
      {
        if( f_serial > other.f_serial )
          result = 1;
        else if( f_serial < other.f_serial )
          result = -1;
      }
      
      if( 0 == result && (flags & EsFirmwareIdCmpFlag$$Version))
      {
        if(  f_fwVer > other.f_fwVer )
          result = 1;
        else if( f_fwVer < other.f_fwVer )
          result = -1;
      }
    }
    
    return result;
  }

  function compare(other)
  {
    return comparePartial(other, EsFirmwareIdCmpFlag$$Significant);
  }
  
  function asString(flags)
  @help = "Return string representation of the hardware id depending on formatting flags";
  var result = "";
  {
    if( flags & EsFirmwareIdFmtFlag$$DescrLong )
      result += deviceDescriptionLongGet(f_type);
    else
      result += deviceDescriptionShortGet(f_type);
    
    if( flags & EsFirmwareIdFmtFlag$$Serial )
    {
      if( !result#isEmpty() )
        result += "; ";
      result += f_serial.asString();
    }
    
    if( flags & EsFirmwareIdFmtFlag$$Version )
    {
      if( !result#isEmpty() )
        result += "; ";
      result += f_fwVer.asString();
    }

    if( (flags & EsFirmwareIdFmtFlag$$UID) && hasField("f_uid") )
    {
      if( !result#isEmpty() )
        result += "; ";
      result += fieldGet("f_uid").asString();
    }

    return result;
  }

  function asString()
    @help = "Return standard string representation of the hardware id";
  {
    return asString(EsFirmwareIdFmtFlag$$DescrLong|
                    EsFirmwareIdFmtFlag$$Serial|
                    EsFirmwareIdFmtFlag$$Version|
                    EsFirmwareIdFmtFlag$$UID);  
  }
  
  /// Return firmware ID string in universal parseable form
  function asIdString()
  var result;
  {
    result = "T:" + f_type;
    result += ",Y:" + f_serial.f_year;
    result += ",O:" + f_serial.f_order;
    result += ",V:" + f_fwVer.asString();
    
    if( hasField("f_uid") )
      result += ",U:" + fieldGet("f_uid").asString();
        
    if( hasField("f_funcMask") )
      result += EsStr::format(",F:0x%0X", fieldGet("f_funcMask"));    
    
    return result;
  }
  
  new()
  {
    f_type = EsDeviceType$$ECOL1;
  }
  
  new(type)
  {
    f_type = type;
  }
  
  /// Properties
  ///
  
  property fwIdString;
  read: { return asString(); }
  
  // read-only access to the dev id components
  property devType;
  read: { return f_type; }
  
  property devTypeName;
  read: { return deviceDescriptionLongGet(f_type); }

  property ver;
  read: { return f_fwVer; }
  
  property verMajor;
  read: { return f_fwVer.f_major; }

  property verMinor;
  read: { return f_fwVer.f_minor; }

  property order;
  read: { return f_order; }  

  property year;
  read: { return f_year; }

  property month;
  read: { return f_month; }

  property day;
  read: { return f_day; }
  
  property countryCode;
  read: { return f_countryCode; }
  
  property hwConfigInfo;
  read: { return f_hwConfig; }
}

/// 192-byte Software information block now includes universal 64 bit firmware information block
object EsSoftwareInfo 
  @fixedSize = 192;
{
  EsFirmwareSwInfo f_fwSwInfo;
  EsSoftwareCrcInfo f_crcCalibration;
  EseFwInfo f_fwInfo;
  
/// Properties 
/// 
  property fwSoftwareInfo;
  read: { return f_fwSwInfo; }
  
  property calibrationCrcInfo;
  read: { return f_crcCalibration; }
  
  property fwInfo;
  read: { return f_fwInfo; }
}

/// Power status flag masks
enum EsPowerStatusFlag
{
  BATTERY       = 0x01, "Battery attached";
  AUX           = 0x02, "Auxiliary power is ON";
  CHARGING      = 0x04, "Battery is charging";
  FAST_CHARGING = 0x08, "Battery is fast charging";
}

/// Power status structure
object EsPowerStatus
  @help = "Device power status object";
{
  esU16 min;
  esU16 cur;
  esU16 max;
  esU8  flags;
  
  function percentGet()
    @help = "Return power level in percents";
    var deltaFull = max-min, deltaCur = cur-min;
  {
    if( 0 == deltaFull )
      return 0.;
  
    if( deltaCur < 0 )
      deltaCur = 0;
    
    if( deltaCur > deltaFull )
      deltaCur = deltaFull;
      
    return 100. * deltaCur / deltaFull;
  }
  
  // handy flags components reading
  function isOnBattery()
  {
    return flags & EsPowerStatusFlag$$BATTERY;
  }

  function isOnAuxPower()
  {
    return flags & EsPowerStatusFlag$$AUX;
  }

  function isCharging()
  {
    return flags & EsPowerStatusFlag$$CHARGING;
  }

  function asString()
  var flagsStr = "";
  {
    if( isOnBattery() ) 
      flagsStr += EsPowerStatusFlag$$BATTERY$$label;
    if( isOnAuxPower() )
    {
      if( flagsStr )
        flagsStr += ", ";
      flagsStr += EsPowerStatusFlag$$AUX$$label;
    }
    if( isCharging() )
    {
      if( flagsStr )
        flagsStr += ", ";
      flagsStr += EsPowerStatusFlag$$CHARGING$$label;
    }
    return EsStr::format("Power level: %0.1f%%, status: %s", percentGet(), flagsStr);
  }  
  
  property level;
  read: { return percentGet(); }
  
  property usesBattery;
  read: { return isOnBattery(); }

  property usesAuxPower;
  read: { return isOnAuxPower(); }
  
  property charging;
  read: { return isCharging(); }
}

// memory space units
enum EsMemoryUnit
{
  Bytes   = 0, "Bytes";
  Kbytes   = 1, "Kilobytes";
  Mbytes  = 2, "Megabytes";
  Gbytes  = 3, "Gigabytes";
}

object EsMemSpaceInfo 
{
  esU16 count;
  esU16 frac;
  esU8 unit;
    @restriction = EsMemoryUnit;
  esU8 dummy;
}

/// RPC accessed filesystem - related structs and enums

/// File system item attribute enumeration
enum EsFsItemAttribute
{
  ReadOnly        = 0x01, "Read only";
  Hidden          = 0x02, "Hidden";
  System          = 0x04, "System";
  VolumeLabel      = 0x08, "Volume";
  Directory        = 0x10, "Directory";
  Archive          = 0x20, "Archive";
}

/// File system request result enumeration
enum EsFsResult 
{
  OK                   = 0, "Succeeded";
  ErrHardware          = 1, "A hardware error occurred in the low level storage I/O layer";
  ErrInternal          = 2, "Internal storage engine operation failed";
  ErrNotReady          = 3, "The storage hardware is not ready";
  ErrNoFile            = 4, "File is not found";
  ErrNoPath            = 5, "Path is not found";
  ErrNameInvalid      = 6, "The filesystem object's name is invalid";
  ErrAccessDenied      = 7, "Access to filesystem object is denied";
  ErrExist            = 8, "Filesystem object already exists";
  ErrObjectInvalid    = 9, "Filesystem object is invalid";
  ErrWriteProtected    = 10,"The storage is write protected";
  ErrDriveInvalid      = 11,"The logical drive is invalid";
  ErrNoWorkarea        = 12,"The volume has no work area";
  ErrNoFilesystem      = 13,"There is no valid filesystem found";
  ErrMakeFilesystem    = 14,"The 'make filesystem' call was aborted due to any parameter error";
  ErrAccessTmo        = 15,"Could not acquire access the filesystem within defined period";
  ErrLocked           = 16,"The filesystem operation was rejected due to sharing violation";
  ErrNotEnoughMem      = 17,"Working buffer could not be allocated, not enough memory";
  ErrTooManyOpenFiles  = 18,"Open files count exceeds the allowed margin";
  ErrParamInvalid      = 19,"Filesystem low level operation parameter is invalid";
}

// File system item struct. used in rpc
// directory listing, rpc FS functions
//
object EsFsItem
{
  esU32 f_size;    /// <file size
  esDT f_ts;    /// <file time stamp
  esU8  f_attrs;    /// <file attributes
  esU8 f_name[13];  /// <file name (short)
  
/// Properties
///
/// Item name access as string
  property name;
  read: { return EsStr::fromByteString(f_name$buffer); }
  write: 
  var bs = EsStr::toByteString(__value);
  {  
    bs#countSet(13);
    bs[12] = 0;
    f_name$buffer = bs; 
  }
}

/// File system enumeration|search result struct
object EsFsItemResult
{
  esU16 f_result;
  if( EsFsResult$$OK == f_result )
    EsFsItem f_item;

	property isOk;
	read: { return EsFsResult$$OK == f_result; }
	
	property result;
	read: { return f_result$value; }

	property item;
	read: { 		
		if( hasField("f_item") )
			return fieldGet("f_item");
	}
}

/// File system space info
object EsFsSpaceInfo
{
  EsMemSpaceInfo f_total;
  EsMemSpaceInfo f_free;
}

/// File system free space info query result
object EsFsSpaceInfoResult
{
  esU16 f_result;
  if( EsFsResult$$OK == f_result )
    EsFsSpaceInfo f_info;
		
	property isOk;
	read: { return EsFsResult$$OK == f_result; }
	
	property result;
	read: { return f_result$value; }
	
	property info;
	read: { 
		if( hasField("f_info") )
			return fieldGet("f_info");
	}
}

/// File read request result
object EsFsFileReadRequest
{
  esU16 f_result;
  if( EsFsResult$$OK == f_result )
    esU32 f_chunks;
		
	property isOk;
	read: { return EsFsResult$$OK == f_result; }
	
	property result;
	read: { return f_result$value; }
	
	property chunks;
	read: { 
		if( hasField("f_chunks") )
			return fieldGet("f_chunks")$value;
	}
}

function fsResultStringGet(fsResult)
{
  if( fsResult in EsFsResult )
    return EsFsResult.valueLabelGet(fsResult);
  
  if( !fsResult#isEmpty() )
    return EsStr::format("Unknown filesystem operation result code: %d", fsResult);
    
  return "";
}
// --------------------------- end standard device objects
