##require( "core.ess" );

// ---------------- ekosfera binary data file parser

// standard sizes & offsets
enum EsBinDataFile 
{
  PageSize       = 128;  // binary file page size in bytes
  TagSize       = 8;    // file tag size in bytes
  HdrSize        = 16;    // file common header part size (tag+entrySize+entryCount)
  SpaceSize      = 110;  // page space available for data (128-EsBinDataFilePageHdr-CRC16)
}

// page tags 
//
// standard file page tags: HDR_MAIN, HDR, DATA, 8 0s == EMPTY_PAGE
const c_hdrMainTag             = "HDRMAIN ";
const c_hdrMainAdditionalTag   = "HDRMAIN+";
const c_hdrTag                = "HDR     ";
const c_hdrAdditionalTag       = "HDR+    ";
const c_dataTag                = "DATA    ";
const c_dataAdditionalTag      = "DATA+   ";
const c_emptyTag              = "\0\0\0\0\0\0\0\0";

// custom data header tags && data entries registry
//
enum EsBinDataFileRegistry
{
  Tags = 0;
  DataEntryTypes = 1;
}

const c_binDataFileRegistry = [
[
/// pha-01 tags
/// old ones
"LUX     ", 
"CDM     ", 
"KEO     ",
/// new ones
"PHA01LUX",
"PHA01CDM",
"PHA01KEO",
/// mk-01 tags
/// old ones
"TH      ", 
"THV     ", 
"IDX     ",
/// new ones
"ET01TH  ",
"ET01THV ",
"ET01IDX ",
/// OCTAVA
/// OCTAVA P381x
"P381XGM ",
"P381XCM ",
"P381X50M",
/// OCTAVA P380e
"P380EST ",
/// Radon radiometer RAD01
"RAD01   "
],
/// Data entry parsers registry
[
/// pha-01 data entries
/// old ones
"EsBinDataFileIlluminosityEntry", 
"EsBinDataFileLuminosityEntry",
"EsBinDataFileKeoEntry",
/// new ones
"EsBinDataFileIlluminosityEntry2", 
"EsBinDataFileLuminosityEntry2",
"EsBinDataFileKeoEntry",
/// mk-01 data entries
/// old ones
"EsBinDataFileClimaticBaseEntry",
"EsBinDataFileClimaticVelocityEntry",
"EsBinDataFileClimaticIndexesEntry",
/// new ones
"EsBinDataFileClimaticBaseEntry",
"EsBinDataFileClimaticVelocityEntry",
"EsBinDataFileClimaticIndexesEntry",
/// OCTAVA entries
/// OCTAVA P381x
"P381xGeoDataEntry",
"P381xConstDataEntry",
"P381x50hzDataEntry",
/// OCTAVA P380E
"P380eDataEntry",
/// Radon radiometer RAD-01
"UINT16"
]
];

function dataFileRegistryTagIdxFind(tag)
  var tagStr, tagIdx = 0;
{
  foreach( tagStr in c_binDataFileRegistry[EsBinDataFileRegistry$$Tags] )
  {
    if( tag == tagStr )
      return tagIdx;
      
    ++tagIdx;
  }
  
  return -1;
}

// tag class
object EsBinDataFileTag
{
  UINT8 f_tagStr[EsBinDataFile$$TagSize];
  
  // tag services
  //
	// string conversion
	function asString()
	{
		return EsStr::fromByteString(f_tagStr$buffer);
	}
	
  // string comparison
  function compare(tagStr)
  {
    if( tagStr != asString() )
      return -1;
          
    return 0;
  }
  
/// Properties
	// access tag as string
	property tag;
	read: { return asString(); }
  // predefined headers check
  property isHdrMain;
  read: { return 0 == compare(c_hdrMainTag); }
  property isHdrMainAdditional;
	read: { return 0 == compare(c_hdrMainAdditionalTag); }  
  property isHdr;
  read: { return 0 == compare(c_hdrTag); }
  property isHdrAdditional;
  read: { return 0 == compare(c_hdrAdditionalTag); }
  property isData;
  read: { return 0 == compare(c_dataTag); }
  property isDataAdditional;
  read: { return 0 == compare(c_dataAdditionalTag); }  
  property isEmpty;
  read: { return 0 == compare(c_emptyTag); }
}

// ----------------------- Page header record
object EsBinDataFilePageHdr
{
  EsBinDataFileTag f_tag;
  UINT32 entrySize;
  UINT32 entryCnt;
  if( f_tag$isHdrMain ||
      f_tag$isHdrMainAdditional ||
      f_tag$isHdr ||
      f_tag$isHdrAdditional )
  {
    EsBinDataFileTag contentTag;
    
    if( -1 != binDataFileRegistryTagFind(contentTag) )
    {
      EsFirmwareId hubId;
        @label = "Hub ID";
      EsFirmwareId applId;
        @label = "Appliance ID";
    }
    
    if( c_binDataFileRegistry[EsBinDataFileRegistry$$Tags][EsBinDataFileRegistry$$KEO] == contentTag )
      EsFirmwareId auxApplId;
        @label = "Aux. appliance ID";
		else if( RAD01 )		
		{
			DATETIME ts;
				@label = "Timestamp";
			UINT32 errs;
				@label = "Latched errors at the beginning of measurements";
			UINT16 tPump;
				@label = "Pumping duration, s";
			UINT16 tMsr;
				@label = "Measurement duration, minutes";
			FLOAT na;
				@label = "Activity in marked windows";
			UINT32 nt;
				@label = "Thoron events";
			FLOAT temperature;
				@label = "Chamber temperature, °C";
			FLOAT humidity;
				@label = "Relative humidity, %";
			FLOAT pressure;
				@label = "Pressure, mm Hg";
			UINT8 state;      
				@label = "Radiometer peripheral state during measurement";
			UINT8 pumpSpeed;
				@label = "Pump speed at which measurement was made";
			UINT8 markers[3];
				@label = "3 spectrum markers, M0-M1-M2, used in activity measurements";
		}
  }
}

// ----------------------- data entry records
//
// PHA01 appliance
//
// PHA01-LUX
object EsBinDataFileIlluminosityEntry
  @help = "Illuminosity data entry";
{
  DATETIME   ts;
    @label = "Timestamp";
  FLOAT      lux;
    @label = "Illuminosity, lux";
  UINT16    kp;
    @label = "Pulsation, %";
  INT8      temp;
    @label = "T, °C";
}

object  EsBinDataFileIlluminosityEntry2
  @help = "Illuminosity data entry";
{
  DATETIME   ts;
    @label = "Timestamp";
  FLOAT     luxOrg;
		@label = "Original illuminosity, lux";
	FLOAT     luxBgnd;
		@label = "Background illuminosity, lux";
	FLOAT     lux;
		@label = "Original-background illuminosity, lux";
  FLOAT      kpOrg;
		@label = "Original pulsation, %";
  FLOAT      kp;
		@label = "Resulting pulsation, %";
  UINT16    bgndDuration;
		@label = "Duration of background measurement, s";
}

/// PHA01-CDM
object EsBinDataFileLuminosityEntry
  @help = "Luminosity data entry";
{
  DATETIME   ts;
    @label = "Timestamp";
  FLOAT      cdm;
    @label = "Luminosity, cd/m";
  UINT16    kp;
    @label = "Pulsation, %";  
  INT8      temp;
    @label = "T, °C";
}

object EsBinDataFileLuminosityEntry2
  @help = "Luminosity data entry";
{
  DATETIME   ts;
    @label = "Timestamp";
  FLOAT      cdm;
    @label = "Luminosity, cd/m";
  UINT16    kp;
    @label = "Pulsation, %";  
}

// PHA01-KEO
object EsBinDataFileKeoEntry 
  @help = "KEO data entry";
{
  DATETIME   ts;
    @label = "Timestamp";
  FLOAT      luxIndoors;
    @label = "Indoors illuminosity, lux";    
  FLOAT      luxOutdoors;
    @label = "Outdoors illuminosity, lux";
  FLOAT      keo;
    @label = "KEO, %";
}

// MK01 appliance
//
// MK01-TH
object EsBinDataFileClimaticBaseEntry
  @help = "Basic climatic data";
{
  DATETIME   ts;
    @label = "Timestamp";
  UINT32    state;
    @label = "Data state";
  FLOAT      ta;
    @label = "Air T, °C";
  FLOAT      rh;
    @label = "Relative humidity, %";
  FLOAT      td;
    @label = "Dew point, °C";
  FLOAT      tw;
    @label = "Natural wet-bulb T, °C";
  FLOAT      p;
    @label = "Barometric pressure, Pa";
}

// MK01-THV
object EsBinDataFileClimaticVelocityEntry
  @help = "Climatic data with air velocity";
{
  DATETIME   ts;
    @label = "Timestamp";
  UINT32     state;
    @label = "Data state";
  FLOAT      ta;
    @label = "Air T, °C";
  FLOAT      rh;
    @label = "Relative humidity, %";
  FLOAT      td;
    @label = "Dew point, °C";
  FLOAT      tw;
    @label = "Natural wet-bulb T, °C";
  FLOAT      tr;
		@label = "Radiation temperature, when airflow is less than 1 m/s, °C";
  FLOAT      t0;
		@label = "Resulting temperature, °C";
	FLOAT      w;
		@label = "Heat ratiation density";
	FLOAT      u;		
		@label = "Air velocity, m/s";
	FLOAT      p;
    @label = "Barometric pressure, Pa";
}

// MK01-IDX
object EsBinDataFileClimaticIndexesEntry
  @help = "Climatic indexes";
{
  DATETIME   ts;
    @label = "Timestamp";
  UINT32     state;
    @label = "Data state";
  FLOAT      ta;
    @label = "Air T, °C";
  FLOAT      rh;
    @label = "Relative humidity, %";
  FLOAT      td;
    @label = "Dew point, °C";
  FLOAT      tw;
    @label = "Natural wet-bulb T, °C";
  FLOAT      tg;
    @label = "Globe thermometer T, °C";
  FLOAT      wbgt;
    @label = "Wet bulb globe T, °C";
  FLOAT      wbgts;
    @label = "Wet bulb globe solar T, °C";
  FLOAT      tr;
    @label = "Mean radiant T, °C";
  FLOAT      w;
    @label = "Heat transfer rate, W/m²";
  FLOAT      p;
    @label = "Barometric pressure, Pa";
}

/// OCTAVA P381_X
object P381xGeoDataEntry
	@help = "Geomagnetic field";
{
  DATETIME   	ts;
		@label = "Timestamp";
  UINT32 			duration;
		@label = "Measurement duration, s";
  FLOAT 			mktlExt;
		@label = "External field, mktl";
  DATETIME 		extTs;
		@label = "Timestamp of external field measurement";
  FLOAT 			mktlCur;
		@label = "Current field, mktl";
  FLOAT 			mktlMin;
		@label = "Minimum internal field, detected during measurement, mktl";
  FLOAT 			attCur; 
		@label = "Current field attenuation";
	FLOAT 			attMax;
		@label = "Maximum attenuation, detected during measurement";
}

object P381xConstDataEntry
	@help = "Constant magnetic field";
{
  DATETIME   ts;
		@label = "Timestamp";
  UINT32 		duration;
		@label = "Measurement duration, s";
  FLOAT 		mktlCur;
		@label = "Current field, mktl";
  FLOAT 		mktlMax;
		@label = "Maximum field, detected during measurement, mktl";
}

object P381x50hzDataEntry
	@help = "50hz magnetic field";
{
  DATETIME  	ts;
		@label = "Timestamp";
  UINT32 			duration;
		@label = "Measurement duration, s";
  FLOAT 			mktlCur;
		@label = "Current field, mktl";
  FLOAT 			mktlMax;
		@label = "Maximum field, detected during measurement, mktl";
}


/// OCTAVA P380E
object P380eDataEntry
	@help = "Electrostatic field";
{
  DATETIME 		ts;
		@label = "Timestamp";
  UINT32 			duration;
		@label = "Measurement duration, s";
  FLOAT 			e;
		@label = "Current field, V/m";
  FLOAT 			eMin;
		@label = "Minimum field, detected during measurement, V/m";
  FLOAT 			eMax;
		@label = "Maximum field, detected during measurement, V/m";
}

// --------------- bin file parser functions
//
function binDataFileBufferParse(buff)
  var pageIdx = 0, pagesCnt, tmp, tmpArray = [];
  var chunkStart = 0, dataChunkStart, chunk, checksum16;
  var sessionHdr = [], sessionData = [], result = [];
  var hdr = new EsBinDataFilePageHdr(), stage = 0; // 0 - none, 1 - parsing headers, 2 - parsing data
  var dataEntryType, tmpDataEntry, dataEntryIdx;
{
  if( !buff#isEmpty() && 
      EsVariantType$$VAR_BIN_BUFFER == buff#typeGet() )
  {
    pagesCnt = buff#countGet() / EsBinDataFile$$PageSize;
    
    while(pageIdx < pagesCnt)
    {
      chunkStart += EsBinDataFile$$PageSize;
      chunk = buff#sliceGet(chunkStart, chunkStart+EsBinDataFile$$PageSize);
      checksum16 = new EsChecksum16(chunk);
      if( 0 == checksum16 )
      {
        hdr$buffer = chunk;
        if( hdr.f_tag.isEmpty() )
          break;
        else if( (1 == stage || 2 == stage) 
                  && hdr.f_tag.isData() &&
                  !tmpDataEntry#isEmpty() )
        {
          stage = 2;
          if( hdr.entrySize != tmpDataEntry$size )
            throw EsStr::format("Data entry record '%s' size is wrong, expected %d, got %d",
              dataEntryType, tmpDataEntry$size, hdr.entrySize);

          // parse data entries
          dataChunkStart = chunkStart+EsBinDataFile$$HdrSize;
          for(dataEntryIdx = 0; dataEntryIdx < hdr.entryCnt; ++dataEntryIdx)
          {
            chunk = buff#sliceGet(dataChunkStart, dataChunkStart+hdr.entrySize);
            tmpDataEntry$buffer = chunk;
            sessionData += tmpDataEntry.clone();
            dataChunkStart += hdr.entrySize;
          }
        }  
        else if( hdr.hasField("contentTag") )
        {  
          // reset stage
          stage = 1;

          if( 0 != sessionHdr#countGet() )
          {
            tmpArray += sessionHdr;
            tmpArray += sessionData;
            
            result#append(tmpArray);
            
            // reset temporary array
            tmpArray = [];
            // reset session header
            sessionHdr = [];
            // reset session data
            sessionData = [];            
          }
        
          // check if header is of known type
          if( hdr.hasField("hubId") )
          {
            // assert we have full hub id
            if( EsCoreSize$$FullHardwareId != hdr.hubId$size )
              throw EsStr::format("Hub ID field size is wrong, expected %d, got %d",
                EsCoreSize$$FullHardwareId, hdr.hubId$size);
            
            // fill-in header entries
            tmp = new EsFirmwareId();
            tmp.copyFrom(hdr.hubId);
            sessionHdr += tmp;
            
            tmp = new EsFirmwareId();
            tmp.copyFrom(hdr.applId);
            sessionHdr += tmp;
            
            if( hdr.hasField("auxApplId") )
            {
              tmp = new EsFirmwareId();
              tmp.copyFrom(hdr.auxApplId);
              sessionHdr += tmp;
            }
            
            dataEntryType = 
              c_binDataFileRegistry[EsBinDataFileRegistry$$DataEntryTypes][binDataFileRegistryTagFind(hdr.contentTag)];
            tmpDataEntry = __metaclass.objectCreate(dataEntryType);
          }
        }
      }
      
      ++pageIdx;
    }
      
    if( 2 == stage &&
        0 != sessionHdr#countGet() )
    {
      tmpArray += sessionHdr;
      tmpArray += sessionData;
      
      result#append(tmpArray);
    }
  }
  
  return result;
}

// ---------------- ekosfera binary data file parser end
