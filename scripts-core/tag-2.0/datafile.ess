##require( "core.ess" );

// ---------------- ekosfera binary data file parser

// standard sizes & offsets
enum EsBinDataFile 
{
  PageSize       = 128;  // binary file page size in bytes
  TagSize       = 8;    // file tag size in bytes
  HdrSize        = 16;    // file common header part size (tag+entrySize+entryCount)
  SpaceSize      = 110;  // page space available for data (128-EsBinDataFilePageHdr-CRC16)
}

// page tags 
//
// standard file page tags: HDR_MAIN, HDR, DATA, 8 0s == EMPTY_PAGE
const c_hdrMainTag             = "HDRMAIN ";
const c_hdrMainAdditionalTag   = "HDRMAIN+";
const c_hdrTag                = "HDR     ";
const c_hdrAdditionalTag       = "HDR+    ";
const c_dataTag                = "DATA    ";
const c_dataAdditionalTag      = "DATA+   ";
const c_emptyTag              = "\0\0\0\0\0\0\0\0";

// tag class
object EsBinDataFileTag
{
  UINT8 f_tagStr[EsBinDataFile$$TagSize];
  
  // tag services
  //
	/// To string conversion
	function asString()
	{
		return EsStr::fromByteString(f_tagStr$buffer);
	}
	
	/// From string conversion
	function tagFromString(tagStr)
	{
	  if( EsBinDataFile$$TagSize != tagStr#countGet() )
      throw EsStr::format("Tag string length must be %d symbols", EsBinDataFile$$TagSize);
    f_tagStr$buffer = EsStr::toByteString(tagStr);
	}
	
  // string comparison
  function compare(tagStr)
  {
    if( tagStr != asString() )
      return -1;
          
    return 0;
  }
  
	/// Custom stream writer
	function streamWrite(stream)
	{
		stream.valueWrite( asString() );
	}
	
	/// Custom stream reader
	function streamRead(stream)
	{
		tagFromString( stream.valueRead() );
	}
	
/// Properties
	// access tag as string
	property tag;
	read: { return asString(); }
	write: { tagFromString(__value); }
  // predefined headers check
  property isHdrMain;
  read: { return 0 == compare(c_hdrMainTag); }
  property isHdrMainAdditional;
	read: { return 0 == compare(c_hdrMainAdditionalTag); }  
  property isHdr;
  read: { return 0 == compare(c_hdrTag); }
  property isHdrAdditional;
  read: { return 0 == compare(c_hdrAdditionalTag); }
  property isData;
  read: { return 0 == compare(c_dataTag); }
  property isDataAdditional;
  read: { return 0 == compare(c_dataAdditionalTag); }  
  property empty;
  read: { return 0 == compare(c_emptyTag); }
}

// ----------------------- data entry records
//
// PHA01 appliance
//
// PHA01-LUX
object EsBinDataFileIlluminosityEntry
  @help = "Illuminosity data entry";
{
  DATETIME   f_ts;
    @label = "Timestamp";
  FLOAT      f_lux;
    @label = "Illuminosity, lux";
  UINT16    f_kp;
    @label = "Pulsation, %";
  INT8      f_temp;
    @label = "T, °C";
}

object  EsBinDataFileIlluminosityEntry2
  @help = "Illuminosity data entry";
{
  DATETIME   f_ts;
    @label = "Timestamp";
  FLOAT     f_luxOrg;
		@label = "Original illuminosity, lux";
	FLOAT     f_luxBgnd;
		@label = "Background illuminosity, lux";
	FLOAT     f_lux;
		@label = "Original-background illuminosity, lux";
  FLOAT      f_kpOrg;
		@label = "Original pulsation, %";
  FLOAT      f_kp;
		@label = "Resulting pulsation, %";
  UINT16    f_bgndDuration;
		@label = "Duration of background measurement, s";
}

/// PHA01-CDM
object EsBinDataFileLuminosityEntry
  @help = "Luminosity data entry";
{
  DATETIME   f_ts;
    @label = "Timestamp";
  FLOAT      f_cdm;
    @label = "Luminosity, cd/m";
  UINT16    f_kp;
    @label = "Pulsation, %";  
  INT8      f_temp;
    @label = "T, °C";
}

object EsBinDataFileLuminosityEntry2
  @help = "Luminosity data entry";
{
  DATETIME   f_ts;
    @label = "Timestamp";
  FLOAT      f_cdm;
    @label = "Luminosity, cd/m";
  UINT16    f_kp;
    @label = "Pulsation, %";  
}

// PHA01-KEO
object EsBinDataFileKeoEntry 
  @help = "KEO data entry";
{
  DATETIME   f_ts;
    @label = "Timestamp";
  FLOAT      f_luxIndoors;
    @label = "Indoors illuminosity, lux";    
  FLOAT      f_luxOutdoors;
    @label = "Outdoors illuminosity, lux";
  FLOAT      f_keo;
    @label = "KEO, %";
}

// MK01 appliance
//
// MK01-TH
object EsBinDataFileClimaticBaseEntry
  @help = "Basic climatic data";
{
  DATETIME   f_ts;
    @label = "Timestamp";
  UINT32    f_state;
    @label = "Data state";
  FLOAT      f_ta;
    @label = "Air T, °C";
  FLOAT      f_rh;
    @label = "Relative humidity, %";
  FLOAT      f_td;
    @label = "Dew point, °C";
  FLOAT      f_tw;
    @label = "Natural wet-bulb T, °C";
  FLOAT      f_p;
    @label = "Barometric pressure, Pa";
}

// MK01-THV
object EsBinDataFileClimaticVelocityEntry
  @help = "Climatic data with air velocity";
{
  DATETIME   f_ts;
    @label = "Timestamp";
  UINT32     f_state;
    @label = "Data state";
  FLOAT      f_ta;
    @label = "Air T, °C";
  FLOAT      f_rh;
    @label = "Relative humidity, %";
  FLOAT      f_td;
    @label = "Dew point, °C";
  FLOAT      f_tw;
    @label = "Natural wet-bulb T, °C";
  FLOAT      f_tr;
		@label = "Radiation temperature, when airflow is less than 1 m/s, °C";
  FLOAT      f_t0;
		@label = "Resulting temperature, °C";
	FLOAT      f_w;
		@label = "Heat ratiation density";
	FLOAT      f_u;		
		@label = "Air velocity, m/s";
	FLOAT      f_p;
    @label = "Barometric pressure, Pa";
}

// MK01-IDX
object EsBinDataFileClimaticIndexesEntry
  @help = "Climatic indexes";
{
  DATETIME   f_ts;
    @label = "Timestamp";
  UINT32     f_state;
    @label = "Data state";
  FLOAT      f_ta;
    @label = "Air T, °C";
  FLOAT      f_rh;
    @label = "Relative humidity, %";
  FLOAT      f_td;
    @label = "Dew point, °C";
  FLOAT      f_tw;
    @label = "Natural wet-bulb T, °C";
  FLOAT      f_tg;
    @label = "Globe thermometer T, °C";
  FLOAT      f_wbgt;
    @label = "Wet bulb globe T, °C";
  FLOAT      f_wbgts;
    @label = "Wet bulb globe solar T, °C";
  FLOAT      f_tr;
    @label = "Mean radiant T, °C";
  FLOAT      f_w;
    @label = "Heat transfer rate, W/m²";
  FLOAT      f_p;
    @label = "Barometric pressure, Pa";
}

/// OCTAVA P381_X
object P381xGeoDataEntry
	@help = "Geomagnetic field";
{
  DATETIME   	f_ts;
		@label = "Timestamp";
  UINT32 			f_duration;
		@label = "Measurement duration, s";
  FLOAT 			f_mktlExt;
		@label = "External field, mktl";
  DATETIME 		f_extTs;
		@label = "Timestamp of external field measurement";
  FLOAT 			f_mktlCur;
		@label = "Current field, mktl";
  FLOAT 			f_mktlMin;
		@label = "Minimum internal field, detected during measurement, mktl";
  FLOAT 			f_attCur; 
		@label = "Current field attenuation";
	FLOAT 			f_attMax;
		@label = "Maximum attenuation, detected during measurement";
}

object P381xConstDataEntry
	@help = "Constant magnetic field";
{
  DATETIME   f_ts;
		@label = "Timestamp";
  UINT32 		f_duration;
		@label = "Measurement duration, s";
  FLOAT 		f_mktlCur;
		@label = "Current field, mktl";
  FLOAT 		f_mktlMax;
		@label = "Maximum field, detected during measurement, mktl";
}

object P381x50hzDataEntry
	@help = "50hz magnetic field";
{
  DATETIME  	f_ts;
		@label = "Timestamp";
  UINT32 			f_duration;
		@label = "Measurement duration, s";
  FLOAT 			f_mktlCur;
		@label = "Current field, mktl";
  FLOAT 			f_mktlMax;
		@label = "Maximum field, detected during measurement, mktl";
}

/// OCTAVA P380E
object P380eDataEntry
	@help = "Electrostatic field";
{
  DATETIME 		f_ts;
		@label = "Timestamp";
  UINT32 			f_duration;
		@label = "Measurement duration, s";
  FLOAT 			f_e;
		@label = "Current field, V/m";
  FLOAT 			f_eMin;
		@label = "Minimum field, detected during measurement, V/m";
  FLOAT 			f_eMax;
		@label = "Maximum field, detected during measurement, V/m";
}

// ----------------------- Generalized page record
object EsBinDataFilePage
{
	// member vars
	var m_contentTagStr;
	
	// fields
  EsBinDataFileTag f_tag;
  UINT32 f_entrySize;
  UINT32 f_entryCnt;
	
  if( f_tag$isHdrMain ||
      f_tag$isHdrMainAdditional ||
      f_tag$isHdr ||
      f_tag$isHdrAdditional )
  {
    EsBinDataFileTag f_contentTag;
		
    if( f_contentTag$tag in [		/// pha-01 tags
																// old ones
																"LUX     ", 
																"CDM     ", 
																"KEO     ",
																// new ones
																"PHA01LUX",
																"PHA01CDM",
																"PHA01KEO",
																// mk-01 tags
																// old ones
																"TH      ", 
																"THV     ", 
																"IDX     ",
																// new ones
																"ET01TH  ",
																"ET01THV ",
																"ET01IDX ",
																// OCTAVA
																// OCTAVA P381x
																"P381XGM ",
																"P381XCM ",
																"P381X50M",
																// OCTAVA P380e
																"P380EST ",
																// Radon radiometer RAD01
																"RAD01   "
																] )
    {
      EsFirmwareId f_hubId;
        @label = "Hub ID";
      EsFirmwareId f_applId;
        @label = "Appliance ID";
  
			if( f_contentTag$tag in ["KEO     ", "PHA01KEO"] )
			{
				EsFirmwareId f_auxApplId;
					@label = "Aux. appliance ID";
			}
			else if( "RAD01   " == f_contentTag$tag )		
			{
				DATETIME f_ts;
					@label = "Timestamp";
				UINT32 f_errs;
					@label = "Latched errors at the beginning of measurements";
				UINT16 f_tPump;
					@label = "Pumping duration, s";
				UINT16 f_tMsr;
					@label = "Measurement duration, minutes";
				FLOAT f_na;
					@label = "Activity in marked windows";
				UINT32 f_nt;
					@label = "Thoron events";
				FLOAT f_temperature;
					@label = "Chamber temperature, °C";
				FLOAT f_humidity;
					@label = "Relative humidity, %";
				FLOAT f_pressure;
					@label = "Pressure, mm Hg";
				UINT8 f_state;      
					@label = "Radiometer peripheral state during measurement";
				UINT8 f_pumpSpeed;
					@label = "Pump speed at which measurement was made";
				UINT8 f_markers[3];
					@label = "3 spectrum markers, M0-M1-M2, used in activity measurements";
			}
		}
  }
	else if( f_tag$isData ||
					 f_tag$isDataAdditional	)
	{
		//conditional data arrays
		if( "LUX     " == m_contentTagStr )
			EsBinDataFileIlluminosityEntry f_nodes[f_entryCnt];
		else if( "PHA01LUX" == m_contentTagStr )
			EsBinDataFileIlluminosityEntry2 f_nodes[f_entryCnt];
		else if( "CDM     " ==  m_contentTagStr )
			EsBinDataFileLuminosityEntry f_nodes[f_entryCnt];
		else if( "PHA01CDM" ==  m_contentTagStr )
			EsBinDataFileLuminosityEntry2 f_nodes[f_entryCnt];
		else if( m_contentTagStr in ["KEO     ", "PHA01KEO"] )
			EsBinDataFileKeoEntry f_nodes[f_entryCnt];
		else if( m_contentTagStr in ["TH      ", "ET01TH  "] )
			EsBinDataFileClimaticBaseEntry f_nodes[f_entryCnt];
		else if( m_contentTagStr in ["THV     ", "ET01THV "] )
			EsBinDataFileClimaticVelocityEntry f_nodes[f_entryCnt];
		else if( m_contentTagStr in ["IDX     ", "ET01IDX "] )
			EsBinDataFileClimaticIndexesEntry f_nodes[f_entryCnt];
		else if( "P381XGM " == m_contentTagStr )
			P381xGeoDataEntry f_nodes[f_entryCnt];
		else if( "P381XCM " == m_contentTagStr )
			P381xConstDataEntry f_nodes[f_entryCnt];
		else if( "P381X50M" == m_contentTagStr )
			P381x50hzDataEntry f_nodes[f_entryCnt];
		else if( "P380EST " == m_contentTagStr )
			P380eDataEntry f_nodes[f_entryCnt];
		else if( "RAD01   " == m_contentTagStr )
			UINT16 f_nodes[f_entryCnt];
	}

/// Methods
///
/// Custom stream writer
	function streamWrite(stream)
	{
		stream.propertiesWrite(this);
		stream.fieldsWrite(this);
	}
	
/// Custom stream reader
	function streamRead(stream)
	{
		stream.propertiesRead(this);
		stream.fieldsRead(this);	
	}
	
/// Properties
///
/// Delegated from f_tag
  property isHdrMain;
  read: { return f_tag$isHdrMain; }
  property isHdrMainAdditional;
	read: { return f_tag$isHdrMainAdditional; }  
  property isHdr;
  read: { return f_tag$isHdr; }
  property isHdrAdditional;
  read: { return f_tag$isHdrAdditional; }
  property isData;
  read: { return f_tag$isData; }
  property isDataAdditional;
  read: { return f_tag$isDataAdditional; }  
  property empty;
  read: { return f_tag$empty; }
/// content tag string
	property contentTagStr; @persistent;
	read: 
	{
		if( hasField("f_contentTag") )
			return fieldGet("f_contentTag")$tag;
		else if( !m_contentTagStr#isEmpty() )
			return m_contentTagStr#asString();
		
		return "";
	}
	write:
	{
		// NB! write only to the m_contentTagStr var, do not try to change f_contentTag field
		m_contentTagStr = __value;
	}
}

// --------------- bin file parser functions
//
function binDataFileBufferParse(buff)
 var cs16, cs16calc = new EsChecksum16(), pageIdx, pagesCnt, 
	pageBuff, pageBuffStart = 0, pageBuffEnd = EsBinDataFile$$PageSize, 
	curContentTagStr, pg, result = [];
{
  if( !buff#isEmpty() )
  {
		buff = buff#asBinBuffer();
    pagesCnt = buff#countGet() / EsBinDataFile$$PageSize;
    for(pageIdx = 0; pageIdx < pagesCnt; ++pageIdx)
    {
		  pageBuff = buff#sliceGet(pageBuffStart, pageBuffEnd);
			cs16calc$buffer = pageBuff;
			cs16 = cs16calc$value;
      if( 0 == cs16 )
			{
				pg = new EsBinDataFilePage();
				pg$contentTagStr = curContentTagStr;
				pg$buffer = pageBuff;
				curContentTagStr = pg$contentTagStr;
				result += pg;
				pageBuffStart = pageBuffEnd;
				pageBuffEnd += EsBinDataFile$$PageSize;
			}
// todo: report invalid page cs16	else
    }
  }
  
  return result;
}

// ---------------- ekosfera binary data file parser end
