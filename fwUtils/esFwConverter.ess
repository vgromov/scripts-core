// Prepare firmware hex image, or separate bin images for
// compiled-in usage in firmware programmer module
##require("esFwBinary.ess");

function convert(inFile, outFile, userAppOffs, initialUserAppCrc)
var hex, binary, inf, of, fp, cwd = EsPath::cwdGet(), uoutFile, hdrAndApp;
{
  EsScriptDebug::log("cwd: %s", cwd);
  fp = EsPath::createFromFilePath(inFile);
  inFile = fp.pathGet(EsPathFlag$$Default, cwd);
  fp = EsPath::createFromFilePath(outFile);
  outFile = fp.pathGet(EsPathFlag$$Default, cwd);
      
  inf = new EsFile(inFile, EsFileFlag$$Read|EsFileFlag$$Text);
  inf.open();
  hex = inf.readAllAsString();
  inf.close();
  
  EsScriptDebug::log("Converting hex to binary...");
  binary = new EsFwBinary(hex);
  
  if( !userAppOffs#isEmpty() && !initialUserAppCrc#isEmpty() )
  {
    // This superceeds functionality of separate user app extractor script
    EsScriptDebug::log("Patching User Application CRC...");
    
    hdrAndApp = binary.patchUserAppCrcExtractUserApp(
      userAppOffs#asULong(),
      initialUserAppCrc#asULong()
    );

    EsScriptDebug::log("Writing userapp extraction result...");

    // prepend out file name with "u" 
    fp$fileName = "u" + fp$fileName;
    uoutFile = fp.pathGet(EsPathFlag$$Default, cwd);

    of = new EsFile(uoutFile, EsFileFlag$$Write|EsFileFlag$$Text);
    of.open();
    of.stringWrite("// this file is automatically generated and must not be changed\n//\n");
    of.stringWrite("const c_fileHexName = \"");
    of.stringWrite(EsFile::nameExtGet(inFile));
    of.stringWrite("\";\nconst c_start = ");
    of.stringWrite( EsStr::format("0x%08X", userAppOffs) );
    of.stringWrite(";\nconst c_hdr = B\"");
    of.binBufferWrite(hdrAndApp[0]$buffer);
    of.stringWrite("\";\nconst c_bin = B\"");
    of.binBufferWrite(hdrAndApp[1]);
    of.stringWrite("\";\nconst c_created = \"");
    of.stringWrite( EsDateTime::now() );
    of.stringWrite("\";\n");
    of.close();
  }
  
  EsScriptDebug::log("Writing mono firmware conversion result...");
  of = new EsFile(outFile, EsFileFlag$$Write|EsFileFlag$$Text);
  of.open();
  of.stringWrite("// this file is automatically generated and must not be changed\n//\n");
  of.stringWrite("const c_fileHexName = \"");
  of.stringWrite(EsFile::nameExtGet(inFile));
  of.stringWrite("\";\nconst c_start = ");
  of.stringWrite( EsStr::format("0x%08X", binary.m_startAddr) );
  of.stringWrite(";\nconst c_offs = ");
  of.stringWrite( EsStr::format("0x%08X", binary.m_offs) );
  of.stringWrite(";\nconst c_bin = B\"");
  of.binBufferWrite(binary.m_fw);
  of.stringWrite("\";\nconst c_created = \"");
  of.stringWrite( EsDateTime::now() );
  of.stringWrite("\";\n");
  of.close();
}

function convert(inCoreHex, inUserHex, outFile, userAppOffs, initialUserAppCrc)
var hex, binary, ubinary, inf, of, fp, cwd = EsPath::cwdGet(), uoutFile, hdrAndApp;
{
  EsScriptDebug::log("cwd: %s", cwd);
  fp = EsPath::createFromFilePath(inCoreHex);
  inCoreHex = fp.pathGet(EsPathFlag$$Default, cwd);

  fp = EsPath::createFromFilePath(inUserHex);
  inUserHex = fp.pathGet(EsPathFlag$$Default, cwd);

  fp = EsPath::createFromFilePath(outFile);
  outFile = fp.pathGet(EsPathFlag$$Default, cwd);
      
  if( initialUserAppCrc#isEmpty() )
    throw "Initial User binary CRC must not be empty!";

  inf = new EsFile(inCoreHex, EsFileFlag$$Read|EsFileFlag$$Text);
  inf.open();
  hex = inf.readAllAsString();
  inf.close();

  EsScriptDebug::log("Converting CORE hex (%s) to binary...", inCoreHex);
  binary = new EsFwBinary(hex);

  inf = new EsFile(inUserHex, EsFileFlag$$Read|EsFileFlag$$Text);
  inf.open();
  hex = inf.readAllAsString();
  inf.close();

  EsScriptDebug::log("Converting USER hex (%s) to binary...", inUserHex);
  ubinary = new EsFwBinary(hex);

  EsScriptDebug::log(
    "Merging (%s) to (%s) at 0x%08X...", 
    inUserHex,
    inCoreHex,
    userAppOffs#asULong()
  );

  // Merge ubinary FW to binary FW
  binary.mergeWith(
    ubinary,
    userAppOffs#asULong()
  );

  EsScriptDebug::log("Patching User Application CRC...");
  hdrAndApp = binary.patchUserAppCrcExtractUserApp(
    userAppOffs#asULong(),
    initialUserAppCrc#asULong()
  );

  EsScriptDebug::log("Writing userapp extraction result...");
  // prepend out file name with "u" 
  fp$fileName = "u" + fp$fileName;
  uoutFile = fp.pathGet(EsPathFlag$$Default, cwd);

  of = new EsFile(uoutFile, EsFileFlag$$Write|EsFileFlag$$Text);
  of.open();
  of.stringWrite("// this file is automatically generated and must not be changed\n//\n");
  of.stringWrite("const c_fileHexName = \"");
  of.stringWrite(EsFile::nameExtGet(inUserHex));
  of.stringWrite("\";\nconst c_start = ");
  of.stringWrite( EsStr::format("0x%08X", userAppOffs) );
  of.stringWrite(";\nconst c_hdr = B\"");
  of.binBufferWrite(hdrAndApp[0]$buffer);
  of.stringWrite("\";\nconst c_bin = B\"");
  of.binBufferWrite(hdrAndApp[1]);
  of.stringWrite("\";\nconst c_created = \"");
  of.stringWrite( EsDateTime::now() );
  of.stringWrite("\";\n");
  of.close();
  
  EsScriptDebug::log("Writing mono firmware conversion result...");
  of = new EsFile(outFile, EsFileFlag$$Write|EsFileFlag$$Text);
  of.open();
  of.stringWrite("// this file is automatically generated and must not be changed\n//\n");
  of.stringWrite("const c_fileHexName = \"");
  of.stringWrite(EsFile::nameExtGet(inCoreHex));
  of.stringWrite("\";\nconst c_start = ");
  of.stringWrite( EsStr::format("0x%08X", binary.m_startAddr) );
  of.stringWrite(";\nconst c_offs = ");
  of.stringWrite( EsStr::format("0x%08X", binary.m_offs) );
  of.stringWrite(";\nconst c_bin = B\"");
  of.binBufferWrite(binary.m_fw);
  of.stringWrite("\";\nconst c_created = \"");
  of.stringWrite( EsDateTime::now() );
  of.stringWrite("\";\n");
  of.close();
}

function convert(inFile, outFile)
{
  convert(inFile, outFile, null, null);
}
